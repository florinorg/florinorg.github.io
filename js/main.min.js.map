{"version":3,"sources":["node_modules/browser-pack/_prelude.js","js/dynamics.js","main.min.js","js/main.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","Color","DecomposedMatrix","DecomposedMatrix2D","InterpolableArray","InterpolableColor","InterpolableObject","InterpolableWithUnit","Matrix","Matrix2D","Set","Vector","addTimeout","animationTick","animations","animationsTimeouts","applyDefaults","applyFrame","applyProperties","baseSVG","cacheFn","cancelTimeout","clone","createInterpolable","defaultValueForKey","degProperties","dynamics","getCurrentProperties","interpolate","isDocumentVisible","isSVGElement","lastTime","leftDelayForTimeout","makeArrayFn","observeVisibilityChange","parseProperties","prefixFor","propertyWithPrefix","pxProperties","rAF","roundf","runLoopPaused","runLoopRunning","runLoopTick","setRealTimeout","slow","slowRatio","startAnimation","startRunLoop","svgProperties","timeBeforeVisibilityChange","timeoutLastId","timeouts","toDashed","transformProperties","transformValueForProperty","unitForProperty","__bind","fn","me","apply","arguments","document","visibilityState","tests","fns","addEventListener","_i","_len","_results","push","k","newO","v","func","data","key","result","toString","this","el","args","res","Array","NodeList","HTMLCollection","_ref","prototype","slice","splice","options","defaults","properties","style","format","isSVG","matrix","transforms","contains","setAttribute","decompose","map","transform","join","_ref1","SVGElement","SVGSVGElement","decimal","d","Math","pow","round","array","obj","str","replace","$1","toLowerCase","split","match","unit","parseFloat","axis","parsed","property","value","keys","_j","_len1","window","getComputedStyle","baseVal","consolidate","fromTransform","getAttribute","interpolable","klass","klasses","create","endInterpolable","end","newObj","start","Object","prefix","suffix","values","sep","newValues","min","val","createFromArray","arr","filter","seps","rgb","toRgba","toRgb","toHex","fromHex","hex","hex3","parseInt","g","b","fromRgb","componentToHex","c","color","max","props","applyRotateCenter","endMatrix","newProps","_k","_l","_ref2","translate","rotate","skew","scale","rotateC","m","m2d","negativeTranslate","createSVGMatrix","createElementNS","kx","ky","kz","r0","r1","dot","normalize","combine","atan2","PI","rotateCX","rotateCY","hash","skewX","skewY","els","cross","vector","V","product","A","B","sqrt","newElements","ascl","bscl","toMatrix","decomposedB","only","angle","decomposed","decomposedA","invscale","invth","qa","qb","th","indexOf","quaternion","acos","sin","piDouble","decomposedMatrix","j","temp","w","x","y","z","I","perspective","multiply","inverse","augment","toRightTriangular","transpose","dup","M","cols","elements","ki","kj","nc","ni","nj","returnVector","sum","modulus","col","rows","kp","multiplier","np","p","T","divisor","inverse_elements","new_element","inversePerspectiveMatrix","pdum3","perspectiveMatrix","rightHandSide","row","rowElement","transposedInversePerspectiveMatrix","type","typeKey","_m","_n","_o","_p","_q","_r","index","elementIndex","asin","cos","isNaN","matrixForTransform","matrixEl","createElement","position","visibility","body","appendChild","removeChild","digits","matrixElements","prop","propArray","propertyName","substring","toUpperCase","requestAnimationFrame","keyCode","shiftKey","ctrlKey","toggleSlow","callback","currTime","id","timeToCall","Date","now","setTimeout","animation","toRemoveAnimations","tt","_base","_base1","tStart","duration","curve","initialForce","change","complete","timeoutId","endProperties","startProperties","timeout","stop","animated","css","realTimeoutId","delay","originalDelay","clearTimeout","time","consumedDelay","visible","difference","_len2","linear","spring","A1","A2","decal","frequency","friction","callee","anticipationSize","x0","x1","anticipationStrength","At","frictionT","y0","yS","bounce","gravity","L","bounciness","curves","elasticity","getPointInCurve","H","t2","L2","forceWithGravity","bezier","Bezier","Bezier_","yForX","p0","p1","p2","p3","xTarget","Bs","returnsToSelf","aB","lower","percent","upper","xTolerance","abs","points","_fn","pointA","pointB","B2","cp","easeInOut","easeIn","easeOut","animate","console","log","define","2","Dynamics","smallBeat","count","scales","getElementById","setInterval","./dynamics.js"],"mappings":"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","file":"main.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","// Generated by CoffeeScript 1.7.1\n(function() {\n  var Color, DecomposedMatrix, DecomposedMatrix2D, InterpolableArray, InterpolableColor, InterpolableObject, InterpolableWithUnit, Matrix, Matrix2D, Set, Vector, addTimeout, animationTick, animations, animationsTimeouts, applyDefaults, applyFrame, applyProperties, baseSVG, cacheFn, cancelTimeout, clone, createInterpolable, defaultValueForKey, degProperties, dynamics, getCurrentProperties, interpolate, isDocumentVisible, isSVGElement, lastTime, leftDelayForTimeout, makeArrayFn, observeVisibilityChange, parseProperties, prefixFor, propertyWithPrefix, pxProperties, rAF, roundf, runLoopPaused, runLoopRunning, runLoopTick, setRealTimeout, slow, slowRatio, startAnimation, startRunLoop, svgProperties, timeBeforeVisibilityChange, timeoutLastId, timeouts, toDashed, transformProperties, transformValueForProperty, unitForProperty,\n    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n  isDocumentVisible = function() {\n    return document.visibilityState === \"visible\" || (dynamics.tests != null);\n  };\n\n  observeVisibilityChange = (function() {\n    var fns;\n    fns = [];\n    if (typeof document !== \"undefined\" && document !== null) {\n      document.addEventListener(\"visibilitychange\", function() {\n        var fn, _i, _len, _results;\n        _results = [];\n        for (_i = 0, _len = fns.length; _i < _len; _i++) {\n          fn = fns[_i];\n          _results.push(fn(isDocumentVisible()));\n        }\n        return _results;\n      });\n    }\n    return function(fn) {\n      return fns.push(fn);\n    };\n  })();\n\n  clone = function(o) {\n    var k, newO, v;\n    newO = {};\n    for (k in o) {\n      v = o[k];\n      newO[k] = v;\n    }\n    return newO;\n  };\n\n  cacheFn = function(func) {\n    var data;\n    data = {};\n    return function() {\n      var k, key, result, _i, _len;\n      key = \"\";\n      for (_i = 0, _len = arguments.length; _i < _len; _i++) {\n        k = arguments[_i];\n        key += k.toString() + \",\";\n      }\n      result = data[key];\n      if (!result) {\n        data[key] = result = func.apply(this, arguments);\n      }\n      return result;\n    };\n  };\n\n  makeArrayFn = function(fn) {\n    return function(el) {\n      var args, i, res;\n      if (el instanceof Array || el instanceof NodeList || el instanceof HTMLCollection) {\n        res = (function() {\n          var _i, _ref, _results;\n          _results = [];\n          for (i = _i = 0, _ref = el.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n            args = Array.prototype.slice.call(arguments, 1);\n            args.splice(0, 0, el[i]);\n            _results.push(fn.apply(this, args));\n          }\n          return _results;\n        }).apply(this, arguments);\n        return res;\n      }\n      return fn.apply(this, arguments);\n    };\n  };\n\n  applyDefaults = function(options, defaults) {\n    var k, v, _results;\n    _results = [];\n    for (k in defaults) {\n      v = defaults[k];\n      _results.push(options[k] != null ? options[k] : options[k] = v);\n    }\n    return _results;\n  };\n\n  applyFrame = function(el, properties) {\n    var k, v, _results;\n    if ((el.style != null)) {\n      return applyProperties(el, properties);\n    } else {\n      _results = [];\n      for (k in properties) {\n        v = properties[k];\n        _results.push(el[k] = v.format());\n      }\n      return _results;\n    }\n  };\n\n  applyProperties = function(el, properties) {\n    var isSVG, k, matrix, transforms, v;\n    properties = parseProperties(properties);\n    transforms = [];\n    isSVG = isSVGElement(el);\n    for (k in properties) {\n      v = properties[k];\n      if (transformProperties.contains(k)) {\n        transforms.push([k, v]);\n      } else {\n        if (v.format != null) {\n          v = v.format();\n        } else {\n          v = \"\" + v + (unitForProperty(k, v));\n        }\n        if (isSVG && svgProperties.contains(k)) {\n          el.setAttribute(k, v);\n        } else {\n          el.style[propertyWithPrefix(k)] = v;\n        }\n      }\n    }\n    if (transforms.length > 0) {\n      if (isSVG) {\n        matrix = new Matrix2D();\n        matrix.applyProperties(transforms);\n        return el.setAttribute(\"transform\", matrix.decompose().format());\n      } else {\n        v = (transforms.map(function(transform) {\n          return transformValueForProperty(transform[0], transform[1]);\n        })).join(\" \");\n        return el.style[propertyWithPrefix(\"transform\")] = v;\n      }\n    }\n  };\n\n  isSVGElement = function(el) {\n    var _ref, _ref1;\n    if ((typeof SVGElement !== \"undefined\" && SVGElement !== null) && (typeof SVGSVGElement !== \"undefined\" && SVGSVGElement !== null)) {\n      return el instanceof SVGElement && !(el instanceof SVGSVGElement);\n    } else {\n      return (_ref = (_ref1 = dynamics.tests) != null ? typeof _ref1.isSVG === \"function\" ? _ref1.isSVG(el) : void 0 : void 0) != null ? _ref : false;\n    }\n  };\n\n  roundf = function(v, decimal) {\n    var d;\n    d = Math.pow(10, decimal);\n    return Math.round(v * d) / d;\n  };\n\n  Set = (function() {\n    function Set(array) {\n      var v, _i, _len;\n      this.obj = {};\n      for (_i = 0, _len = array.length; _i < _len; _i++) {\n        v = array[_i];\n        this.obj[v] = 1;\n      }\n    }\n\n    Set.prototype.contains = function(v) {\n      return this.obj[v] === 1;\n    };\n\n    return Set;\n\n  })();\n\n  toDashed = function(str) {\n    return str.replace(/([A-Z])/g, function($1) {\n      return \"-\" + $1.toLowerCase();\n    });\n  };\n\n  pxProperties = new Set('marginTop,marginLeft,marginBottom,marginRight,paddingTop,paddingLeft,paddingBottom,paddingRight,top,left,bottom,right,translateX,translateY,translateZ,perspectiveX,perspectiveY,perspectiveZ,width,height,maxWidth,maxHeight,minWidth,minHeight,borderRadius'.split(','));\n\n  degProperties = new Set('rotate,rotateX,rotateY,rotateZ,skew,skewX,skewY,skewZ'.split(','));\n\n  transformProperties = new Set('translate,translateX,translateY,translateZ,scale,scaleX,scaleY,scaleZ,rotate,rotateX,rotateY,rotateZ,rotateC,rotateCX,rotateCY,skew,skewX,skewY,skewZ,perspective'.split(','));\n\n  svgProperties = new Set('accent-height,ascent,azimuth,baseFrequency,baseline-shift,bias,cx,cy,d,diffuseConstant,divisor,dx,dy,elevation,filterRes,fx,fy,gradientTransform,height,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,letter-spacing,limitingConeAngle,markerHeight,markerWidth,numOctaves,order,overline-position,overline-thickness,pathLength,points,pointsAtX,pointsAtY,pointsAtZ,r,radius,rx,ry,seed,specularConstant,specularExponent,stdDeviation,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,surfaceScale,target,targetX,targetY,transform,underline-position,underline-thickness,viewBox,width,x,x1,x2,y,y1,y2,z'.split(','));\n\n  unitForProperty = function(k, v) {\n    if (typeof v !== 'number') {\n      return '';\n    }\n    if (pxProperties.contains(k)) {\n      return 'px';\n    } else if (degProperties.contains(k)) {\n      return 'deg';\n    }\n    return '';\n  };\n\n  transformValueForProperty = function(k, v) {\n    var match, unit;\n    match = (\"\" + v).match(/^([0-9.-]*)([^0-9]*)$/);\n    if (match != null) {\n      v = match[1];\n      unit = match[2];\n    } else {\n      v = parseFloat(v);\n    }\n    v = roundf(parseFloat(v), 10);\n    if ((unit == null) || unit === \"\") {\n      unit = unitForProperty(k, v);\n    }\n    return \"\" + k + \"(\" + v + unit + \")\";\n  };\n\n  parseProperties = function(properties) {\n    var axis, match, parsed, property, value, _i, _len, _ref;\n    parsed = {};\n    for (property in properties) {\n      value = properties[property];\n      if (transformProperties.contains(property)) {\n        match = property.match(/(translate|rotateC|rotate|skew|scale|perspective)(X|Y|Z|)/);\n        if (match && match[2].length > 0) {\n          parsed[property] = value;\n        } else {\n          _ref = ['X', 'Y', 'Z'];\n          for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n            axis = _ref[_i];\n            parsed[match[1] + axis] = value;\n          }\n        }\n      } else {\n        parsed[property] = value;\n      }\n    }\n    return parsed;\n  };\n\n  defaultValueForKey = function(key) {\n    var v;\n    v = key === 'opacity' ? 1 : 0;\n    return \"\" + v + (unitForProperty(key, v));\n  };\n\n  getCurrentProperties = function(el, keys) {\n    var isSVG, key, matrix, properties, style, v, _i, _j, _len, _len1, _ref;\n    properties = {};\n    isSVG = isSVGElement(el);\n    if (el.style != null) {\n      style = window.getComputedStyle(el, null);\n      for (_i = 0, _len = keys.length; _i < _len; _i++) {\n        key = keys[_i];\n        if (transformProperties.contains(key)) {\n          if (properties['transform'] == null) {\n            if (isSVG) {\n              matrix = new Matrix2D((_ref = el.transform.baseVal.consolidate()) != null ? _ref.matrix : void 0);\n            } else {\n              matrix = Matrix.fromTransform(style[propertyWithPrefix('transform')]);\n            }\n            properties['transform'] = matrix.decompose();\n          }\n        } else {\n          v = style[key];\n          if ((v == null) && svgProperties.contains(key)) {\n            v = el.getAttribute(key);\n          }\n          if (v === \"\" || (v == null)) {\n            v = defaultValueForKey(key);\n          }\n          properties[key] = createInterpolable(v);\n        }\n      }\n    } else {\n      for (_j = 0, _len1 = keys.length; _j < _len1; _j++) {\n        key = keys[_j];\n        properties[key] = createInterpolable(el[key]);\n      }\n    }\n    return properties;\n  };\n\n  createInterpolable = function(value) {\n    var interpolable, klass, klasses, _i, _len;\n    klasses = [InterpolableColor, InterpolableArray, InterpolableObject, InterpolableWithUnit];\n    for (_i = 0, _len = klasses.length; _i < _len; _i++) {\n      klass = klasses[_i];\n      interpolable = klass.create(value);\n      if (interpolable != null) {\n        return interpolable;\n      }\n    }\n    return null;\n  };\n\n  InterpolableObject = (function() {\n    function InterpolableObject(obj) {\n      this.format = __bind(this.format, this);\n      this.interpolate = __bind(this.interpolate, this);\n      this.obj = obj;\n    }\n\n    InterpolableObject.prototype.interpolate = function(endInterpolable, t) {\n      var end, k, newObj, start, v;\n      start = this.obj;\n      end = endInterpolable.obj;\n      newObj = {};\n      for (k in start) {\n        v = start[k];\n        if (v.interpolate != null) {\n          newObj[k] = v.interpolate(end[k], t);\n        } else {\n          newObj[k] = v;\n        }\n      }\n      return new InterpolableObject(newObj);\n    };\n\n    InterpolableObject.prototype.format = function() {\n      return this.obj;\n    };\n\n    InterpolableObject.create = function(value) {\n      var k, obj, v;\n      if (value instanceof Object) {\n        obj = {};\n        for (k in value) {\n          v = value[k];\n          obj[k] = createInterpolable(v);\n        }\n        return new InterpolableObject(obj);\n      }\n      return null;\n    };\n\n    return InterpolableObject;\n\n  })();\n\n  InterpolableWithUnit = (function() {\n    function InterpolableWithUnit(value, prefix, suffix) {\n      this.prefix = prefix;\n      this.suffix = suffix;\n      this.format = __bind(this.format, this);\n      this.interpolate = __bind(this.interpolate, this);\n      this.value = parseFloat(value);\n    }\n\n    InterpolableWithUnit.prototype.interpolate = function(endInterpolable, t) {\n      var end, start;\n      start = this.value;\n      end = endInterpolable.value;\n      return new InterpolableWithUnit((end - start) * t + start, endInterpolable.prefix || this.prefix, endInterpolable.suffix || this.suffix);\n    };\n\n    InterpolableWithUnit.prototype.format = function() {\n      if ((this.prefix == null) && (this.suffix == null)) {\n        return roundf(this.value, 5);\n      }\n      return this.prefix + roundf(this.value, 5) + this.suffix;\n    };\n\n    InterpolableWithUnit.create = function(value) {\n      var match;\n      if (typeof value !== \"string\") {\n        return new InterpolableWithUnit(value);\n      }\n      match = (\"\" + value).match(\"([^0-9.+-]*)([0-9.+-]+)([^0-9.+-]*)\");\n      if (match != null) {\n        return new InterpolableWithUnit(match[2], match[1], match[3]);\n      }\n      return null;\n    };\n\n    return InterpolableWithUnit;\n\n  })();\n\n  InterpolableArray = (function() {\n    function InterpolableArray(values, sep) {\n      this.values = values;\n      this.sep = sep;\n      this.format = __bind(this.format, this);\n      this.interpolate = __bind(this.interpolate, this);\n    }\n\n    InterpolableArray.prototype.interpolate = function(endInterpolable, t) {\n      var end, i, newValues, start, _i, _ref;\n      start = this.values;\n      end = endInterpolable.values;\n      newValues = [];\n      for (i = _i = 0, _ref = Math.min(start.length, end.length); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n        if (start[i].interpolate != null) {\n          newValues.push(start[i].interpolate(end[i], t));\n        } else {\n          newValues.push(start[i]);\n        }\n      }\n      return new InterpolableArray(newValues, this.sep);\n    };\n\n    InterpolableArray.prototype.format = function() {\n      var values;\n      values = this.values.map(function(val) {\n        if (val.format != null) {\n          return val.format();\n        } else {\n          return val;\n        }\n      });\n      if (this.sep != null) {\n        return values.join(this.sep);\n      } else {\n        return values;\n      }\n    };\n\n    InterpolableArray.createFromArray = function(arr, sep) {\n      var values;\n      values = arr.map(function(val) {\n        return createInterpolable(val) || val;\n      });\n      values = values.filter(function(val) {\n        return val != null;\n      });\n      return new InterpolableArray(values, sep);\n    };\n\n    InterpolableArray.create = function(value) {\n      var arr, sep, seps, _i, _len;\n      if (value instanceof Array) {\n        return InterpolableArray.createFromArray(value, null);\n      }\n      if (typeof value !== \"string\") {\n        return;\n      }\n      seps = [' ', ',', '|', ';', '/', ':'];\n      for (_i = 0, _len = seps.length; _i < _len; _i++) {\n        sep = seps[_i];\n        arr = value.split(sep);\n        if (arr.length > 1) {\n          return InterpolableArray.createFromArray(arr, sep);\n        }\n      }\n      return null;\n    };\n\n    return InterpolableArray;\n\n  })();\n\n  Color = (function() {\n    function Color(rgb, format) {\n      this.rgb = rgb != null ? rgb : {};\n      this.format = format;\n      this.toRgba = __bind(this.toRgba, this);\n      this.toRgb = __bind(this.toRgb, this);\n      this.toHex = __bind(this.toHex, this);\n    }\n\n    Color.fromHex = function(hex) {\n      var hex3, result;\n      hex3 = hex.match(/^#([a-f\\d]{1})([a-f\\d]{1})([a-f\\d]{1})$/i);\n      if (hex3 != null) {\n        hex = \"#\" + hex3[1] + hex3[1] + hex3[2] + hex3[2] + hex3[3] + hex3[3];\n      }\n      result = hex.match(/^#([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i);\n      if (result != null) {\n        return new Color({\n          r: parseInt(result[1], 16),\n          g: parseInt(result[2], 16),\n          b: parseInt(result[3], 16),\n          a: 1\n        }, \"hex\");\n      }\n      return null;\n    };\n\n    Color.fromRgb = function(rgb) {\n      var match, _ref;\n      match = rgb.match(/^rgba?\\(([0-9.]*), ?([0-9.]*), ?([0-9.]*)(?:, ?([0-9.]*))?\\)$/);\n      if (match != null) {\n        return new Color({\n          r: parseFloat(match[1]),\n          g: parseFloat(match[2]),\n          b: parseFloat(match[3]),\n          a: parseFloat((_ref = match[4]) != null ? _ref : 1)\n        }, match[4] != null ? \"rgba\" : \"rgb\");\n      }\n      return null;\n    };\n\n    Color.componentToHex = function(c) {\n      var hex;\n      hex = c.toString(16);\n      if (hex.length === 1) {\n        return \"0\" + hex;\n      } else {\n        return hex;\n      }\n    };\n\n    Color.prototype.toHex = function() {\n      return \"#\" + Color.componentToHex(this.rgb.r) + Color.componentToHex(this.rgb.g) + Color.componentToHex(this.rgb.b);\n    };\n\n    Color.prototype.toRgb = function() {\n      return \"rgb(\" + this.rgb.r + \", \" + this.rgb.g + \", \" + this.rgb.b + \")\";\n    };\n\n    Color.prototype.toRgba = function() {\n      return \"rgba(\" + this.rgb.r + \", \" + this.rgb.g + \", \" + this.rgb.b + \", \" + this.rgb.a + \")\";\n    };\n\n    return Color;\n\n  })();\n\n  InterpolableColor = (function() {\n    function InterpolableColor(color) {\n      this.color = color;\n      this.format = __bind(this.format, this);\n      this.interpolate = __bind(this.interpolate, this);\n    }\n\n    InterpolableColor.prototype.interpolate = function(endInterpolable, t) {\n      var end, k, rgb, start, v, _i, _len, _ref;\n      start = this.color;\n      end = endInterpolable.color;\n      rgb = {};\n      _ref = ['r', 'g', 'b'];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        k = _ref[_i];\n        v = Math.round((end.rgb[k] - start.rgb[k]) * t + start.rgb[k]);\n        rgb[k] = Math.min(255, Math.max(0, v));\n      }\n      k = \"a\";\n      v = roundf((end.rgb[k] - start.rgb[k]) * t + start.rgb[k], 5);\n      rgb[k] = Math.min(1, Math.max(0, v));\n      return new InterpolableColor(new Color(rgb, end.format));\n    };\n\n    InterpolableColor.prototype.format = function() {\n      if (this.color.format === \"hex\") {\n        return this.color.toHex();\n      } else if (this.color.format === \"rgb\") {\n        return this.color.toRgb();\n      } else if (this.color.format === \"rgba\") {\n        return this.color.toRgba();\n      }\n    };\n\n    InterpolableColor.create = function(value) {\n      var color;\n      if (typeof value !== \"string\") {\n        return;\n      }\n      color = Color.fromHex(value) || Color.fromRgb(value);\n      if (color != null) {\n        return new InterpolableColor(color);\n      }\n      return null;\n    };\n\n    return InterpolableColor;\n\n  })();\n\n  DecomposedMatrix2D = (function() {\n    function DecomposedMatrix2D(props) {\n      this.props = props;\n      this.applyRotateCenter = __bind(this.applyRotateCenter, this);\n      this.format = __bind(this.format, this);\n      this.interpolate = __bind(this.interpolate, this);\n    }\n\n    DecomposedMatrix2D.prototype.interpolate = function(endMatrix, t) {\n      var i, k, newProps, _i, _j, _k, _l, _len, _len1, _ref, _ref1, _ref2;\n      newProps = {};\n      _ref = ['translate', 'scale', 'rotate'];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        k = _ref[_i];\n        newProps[k] = [];\n        for (i = _j = 0, _ref1 = this.props[k].length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n          newProps[k][i] = (endMatrix.props[k][i] - this.props[k][i]) * t + this.props[k][i];\n        }\n      }\n      for (i = _k = 1; _k <= 2; i = ++_k) {\n        newProps['rotate'][i] = endMatrix.props['rotate'][i];\n      }\n      _ref2 = ['skew'];\n      for (_l = 0, _len1 = _ref2.length; _l < _len1; _l++) {\n        k = _ref2[_l];\n        newProps[k] = (endMatrix.props[k] - this.props[k]) * t + this.props[k];\n      }\n      return new DecomposedMatrix2D(newProps);\n    };\n\n    DecomposedMatrix2D.prototype.format = function() {\n      return \"translate(\" + (this.props.translate.join(',')) + \") rotate(\" + (this.props.rotate.join(',')) + \") skewX(\" + this.props.skew + \") scale(\" + (this.props.scale.join(',')) + \")\";\n    };\n\n    DecomposedMatrix2D.prototype.applyRotateCenter = function(rotateC) {\n      var i, m, m2d, negativeTranslate, _i, _results;\n      m = baseSVG.createSVGMatrix();\n      m = m.translate(rotateC[0], rotateC[1]);\n      m = m.rotate(this.props.rotate[0]);\n      m = m.translate(-rotateC[0], -rotateC[1]);\n      m2d = new Matrix2D(m);\n      negativeTranslate = m2d.decompose().props.translate;\n      _results = [];\n      for (i = _i = 0; _i <= 1; i = ++_i) {\n        _results.push(this.props.translate[i] -= negativeTranslate[i]);\n      }\n      return _results;\n    };\n\n    return DecomposedMatrix2D;\n\n  })();\n\n  baseSVG = typeof document !== \"undefined\" && document !== null ? document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\") : void 0;\n\n  Matrix2D = (function() {\n    function Matrix2D(m) {\n      this.m = m;\n      this.applyProperties = __bind(this.applyProperties, this);\n      this.decompose = __bind(this.decompose, this);\n      if (!this.m) {\n        this.m = baseSVG.createSVGMatrix();\n      }\n    }\n\n    Matrix2D.prototype.decompose = function() {\n      var kx, ky, kz, r0, r1;\n      r0 = new Vector([this.m.a, this.m.b]);\n      r1 = new Vector([this.m.c, this.m.d]);\n      kx = r0.length();\n      kz = r0.dot(r1);\n      r0 = r0.normalize();\n      ky = r1.combine(r0, 1, -kz).length();\n      return new DecomposedMatrix2D({\n        translate: [this.m.e, this.m.f],\n        rotate: [Math.atan2(this.m.b, this.m.a) * 180 / Math.PI, this.rotateCX, this.rotateCY],\n        scale: [kx, ky],\n        skew: kz / ky * 180 / Math.PI\n      });\n    };\n\n    Matrix2D.prototype.applyProperties = function(properties) {\n      var hash, k, props, v, _i, _len, _ref, _ref1;\n      hash = {};\n      for (_i = 0, _len = properties.length; _i < _len; _i++) {\n        props = properties[_i];\n        hash[props[0]] = props[1];\n      }\n      for (k in hash) {\n        v = hash[k];\n        if (k === \"translateX\") {\n          this.m = this.m.translate(v, 0);\n        } else if (k === \"translateY\") {\n          this.m = this.m.translate(0, v);\n        } else if (k === \"scaleX\") {\n          this.m = this.m.scale(v, 1);\n        } else if (k === \"scaleY\") {\n          this.m = this.m.scale(1, v);\n        } else if (k === \"rotateZ\") {\n          this.m = this.m.rotate(v);\n        } else if (k === \"skewX\") {\n          this.m = this.m.skewX(v);\n        } else if (k === \"skewY\") {\n          this.m = this.m.skewY(v);\n        }\n      }\n      this.rotateCX = (_ref = hash.rotateCX) != null ? _ref : 0;\n      return this.rotateCY = (_ref1 = hash.rotateCY) != null ? _ref1 : 0;\n    };\n\n    return Matrix2D;\n\n  })();\n\n  Vector = (function() {\n    function Vector(els) {\n      this.els = els;\n      this.combine = __bind(this.combine, this);\n      this.normalize = __bind(this.normalize, this);\n      this.length = __bind(this.length, this);\n      this.cross = __bind(this.cross, this);\n      this.dot = __bind(this.dot, this);\n      this.e = __bind(this.e, this);\n    }\n\n    Vector.prototype.e = function(i) {\n      if (i < 1 || i > this.els.length) {\n        return null;\n      } else {\n        return this.els[i - 1];\n      }\n    };\n\n    Vector.prototype.dot = function(vector) {\n      var V, n, product;\n      V = vector.els || vector;\n      product = 0;\n      n = this.els.length;\n      if (n !== V.length) {\n        return null;\n      }\n      n += 1;\n      while (--n) {\n        product += this.els[n - 1] * V[n - 1];\n      }\n      return product;\n    };\n\n    Vector.prototype.cross = function(vector) {\n      var A, B;\n      B = vector.els || vector;\n      if (this.els.length !== 3 || B.length !== 3) {\n        return null;\n      }\n      A = this.els;\n      return new Vector([(A[1] * B[2]) - (A[2] * B[1]), (A[2] * B[0]) - (A[0] * B[2]), (A[0] * B[1]) - (A[1] * B[0])]);\n    };\n\n    Vector.prototype.length = function() {\n      var a, e, _i, _len, _ref;\n      a = 0;\n      _ref = this.els;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        e = _ref[_i];\n        a += Math.pow(e, 2);\n      }\n      return Math.sqrt(a);\n    };\n\n    Vector.prototype.normalize = function() {\n      var e, i, length, newElements, _ref;\n      length = this.length();\n      newElements = [];\n      _ref = this.els;\n      for (i in _ref) {\n        e = _ref[i];\n        newElements[i] = e / length;\n      }\n      return new Vector(newElements);\n    };\n\n    Vector.prototype.combine = function(b, ascl, bscl) {\n      var i, result, _i, _ref;\n      result = [];\n      for (i = _i = 0, _ref = this.els.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n        result[i] = (ascl * this.els[i]) + (bscl * b.els[i]);\n      }\n      return new Vector(result);\n    };\n\n    return Vector;\n\n  })();\n\n  DecomposedMatrix = (function() {\n    function DecomposedMatrix() {\n      this.toMatrix = __bind(this.toMatrix, this);\n      this.format = __bind(this.format, this);\n      this.interpolate = __bind(this.interpolate, this);\n    }\n\n    DecomposedMatrix.prototype.interpolate = function(decomposedB, t, only) {\n      var angle, decomposed, decomposedA, i, invscale, invth, k, qa, qb, scale, th, _i, _j, _k, _l, _len, _ref, _ref1;\n      if (only == null) {\n        only = null;\n      }\n      decomposedA = this;\n      decomposed = new DecomposedMatrix;\n      _ref = ['translate', 'scale', 'skew', 'perspective'];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        k = _ref[_i];\n        decomposed[k] = [];\n        for (i = _j = 0, _ref1 = decomposedA[k].length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n          if ((only == null) || only.indexOf(k) > -1 || only.indexOf(\"\" + k + ['x', 'y', 'z'][i]) > -1) {\n            decomposed[k][i] = (decomposedB[k][i] - decomposedA[k][i]) * t + decomposedA[k][i];\n          } else {\n            decomposed[k][i] = decomposedA[k][i];\n          }\n        }\n      }\n      if ((only == null) || only.indexOf('rotate') !== -1) {\n        qa = decomposedA.quaternion;\n        qb = decomposedB.quaternion;\n        angle = qa[0] * qb[0] + qa[1] * qb[1] + qa[2] * qb[2] + qa[3] * qb[3];\n        if (angle < 0.0) {\n          for (i = _k = 0; _k <= 3; i = ++_k) {\n            qa[i] = -qa[i];\n          }\n          angle = -angle;\n        }\n        if (angle + 1.0 > .05) {\n          if (1.0 - angle >= .05) {\n            th = Math.acos(angle);\n            invth = 1.0 / Math.sin(th);\n            scale = Math.sin(th * (1.0 - t)) * invth;\n            invscale = Math.sin(th * t) * invth;\n          } else {\n            scale = 1.0 - t;\n            invscale = t;\n          }\n        } else {\n          qb[0] = -qa[1];\n          qb[1] = qa[0];\n          qb[2] = -qa[3];\n          qb[3] = qa[2];\n          scale = Math.sin(piDouble * (.5 - t));\n          invscale = Math.sin(piDouble * t);\n        }\n        decomposed.quaternion = [];\n        for (i = _l = 0; _l <= 3; i = ++_l) {\n          decomposed.quaternion[i] = qa[i] * scale + qb[i] * invscale;\n        }\n      } else {\n        decomposed.quaternion = decomposedA.quaternion;\n      }\n      return decomposed;\n    };\n\n    DecomposedMatrix.prototype.format = function() {\n      return this.toMatrix().toString();\n    };\n\n    DecomposedMatrix.prototype.toMatrix = function() {\n      var decomposedMatrix, i, j, match, matrix, quaternion, skew, temp, w, x, y, z, _i, _j, _k, _l;\n      decomposedMatrix = this;\n      matrix = Matrix.I(4);\n      for (i = _i = 0; _i <= 3; i = ++_i) {\n        matrix.els[i][3] = decomposedMatrix.perspective[i];\n      }\n      quaternion = decomposedMatrix.quaternion;\n      x = quaternion[0];\n      y = quaternion[1];\n      z = quaternion[2];\n      w = quaternion[3];\n      skew = decomposedMatrix.skew;\n      match = [[1, 0], [2, 0], [2, 1]];\n      for (i = _j = 2; _j >= 0; i = --_j) {\n        if (skew[i]) {\n          temp = Matrix.I(4);\n          temp.els[match[i][0]][match[i][1]] = skew[i];\n          matrix = matrix.multiply(temp);\n        }\n      }\n      matrix = matrix.multiply(new Matrix([[1 - 2 * (y * y + z * z), 2 * (x * y - z * w), 2 * (x * z + y * w), 0], [2 * (x * y + z * w), 1 - 2 * (x * x + z * z), 2 * (y * z - x * w), 0], [2 * (x * z - y * w), 2 * (y * z + x * w), 1 - 2 * (x * x + y * y), 0], [0, 0, 0, 1]]));\n      for (i = _k = 0; _k <= 2; i = ++_k) {\n        for (j = _l = 0; _l <= 2; j = ++_l) {\n          matrix.els[i][j] *= decomposedMatrix.scale[i];\n        }\n        matrix.els[3][i] = decomposedMatrix.translate[i];\n      }\n      return matrix;\n    };\n\n    return DecomposedMatrix;\n\n  })();\n\n  Matrix = (function() {\n    function Matrix(els) {\n      this.els = els;\n      this.toString = __bind(this.toString, this);\n      this.decompose = __bind(this.decompose, this);\n      this.inverse = __bind(this.inverse, this);\n      this.augment = __bind(this.augment, this);\n      this.toRightTriangular = __bind(this.toRightTriangular, this);\n      this.transpose = __bind(this.transpose, this);\n      this.multiply = __bind(this.multiply, this);\n      this.dup = __bind(this.dup, this);\n      this.e = __bind(this.e, this);\n    }\n\n    Matrix.prototype.e = function(i, j) {\n      if (i < 1 || i > this.els.length || j < 1 || j > this.els[0].length) {\n        return null;\n      }\n      return this.els[i - 1][j - 1];\n    };\n\n    Matrix.prototype.dup = function() {\n      return new Matrix(this.els);\n    };\n\n    Matrix.prototype.multiply = function(matrix) {\n      var M, c, cols, elements, i, j, ki, kj, nc, ni, nj, returnVector, sum;\n      returnVector = matrix.modulus ? true : false;\n      M = matrix.els || matrix;\n      if (typeof M[0][0] === 'undefined') {\n        M = new Matrix(M).els;\n      }\n      ni = this.els.length;\n      ki = ni;\n      kj = M[0].length;\n      cols = this.els[0].length;\n      elements = [];\n      ni += 1;\n      while (--ni) {\n        i = ki - ni;\n        elements[i] = [];\n        nj = kj;\n        nj += 1;\n        while (--nj) {\n          j = kj - nj;\n          sum = 0;\n          nc = cols;\n          nc += 1;\n          while (--nc) {\n            c = cols - nc;\n            sum += this.els[i][c] * M[c][j];\n          }\n          elements[i][j] = sum;\n        }\n      }\n      M = new Matrix(elements);\n      if (returnVector) {\n        return M.col(1);\n      } else {\n        return M;\n      }\n    };\n\n    Matrix.prototype.transpose = function() {\n      var cols, elements, i, j, ni, nj, rows;\n      rows = this.els.length;\n      cols = this.els[0].length;\n      elements = [];\n      ni = cols;\n      ni += 1;\n      while (--ni) {\n        i = cols - ni;\n        elements[i] = [];\n        nj = rows;\n        nj += 1;\n        while (--nj) {\n          j = rows - nj;\n          elements[i][j] = this.els[j][i];\n        }\n      }\n      return new Matrix(elements);\n    };\n\n    Matrix.prototype.toRightTriangular = function() {\n      var M, els, i, j, k, kp, multiplier, n, np, p, _i, _j, _ref, _ref1;\n      M = this.dup();\n      n = this.els.length;\n      k = n;\n      kp = this.els[0].length;\n      while (--n) {\n        i = k - n;\n        if (M.els[i][i] === 0) {\n          for (j = _i = _ref = i + 1; _ref <= k ? _i < k : _i > k; j = _ref <= k ? ++_i : --_i) {\n            if (M.els[j][i] !== 0) {\n              els = [];\n              np = kp;\n              np += 1;\n              while (--np) {\n                p = kp - np;\n                els.push(M.els[i][p] + M.els[j][p]);\n              }\n              M.els[i] = els;\n              break;\n            }\n          }\n        }\n        if (M.els[i][i] !== 0) {\n          for (j = _j = _ref1 = i + 1; _ref1 <= k ? _j < k : _j > k; j = _ref1 <= k ? ++_j : --_j) {\n            multiplier = M.els[j][i] / M.els[i][i];\n            els = [];\n            np = kp;\n            np += 1;\n            while (--np) {\n              p = kp - np;\n              els.push(p <= i ? 0 : M.els[j][p] - M.els[i][p] * multiplier);\n            }\n            M.els[j] = els;\n          }\n        }\n      }\n      return M;\n    };\n\n    Matrix.prototype.augment = function(matrix) {\n      var M, T, cols, i, j, ki, kj, ni, nj;\n      M = matrix.els || matrix;\n      if (typeof M[0][0] === 'undefined') {\n        M = new Matrix(M).els;\n      }\n      T = this.dup();\n      cols = T.els[0].length;\n      ni = T.els.length;\n      ki = ni;\n      kj = M[0].length;\n      if (ni !== M.length) {\n        return null;\n      }\n      ni += 1;\n      while (--ni) {\n        i = ki - ni;\n        nj = kj;\n        nj += 1;\n        while (--nj) {\n          j = kj - nj;\n          T.els[i][cols + j] = M[i][j];\n        }\n      }\n      return T;\n    };\n\n    Matrix.prototype.inverse = function() {\n      var M, divisor, els, i, inverse_elements, j, ki, kp, new_element, ni, np, p, _i;\n      ni = this.els.length;\n      ki = ni;\n      M = this.augment(Matrix.I(ni)).toRightTriangular();\n      kp = M.els[0].length;\n      inverse_elements = [];\n      ni += 1;\n      while (--ni) {\n        i = ni - 1;\n        els = [];\n        np = kp;\n        inverse_elements[i] = [];\n        divisor = M.els[i][i];\n        np += 1;\n        while (--np) {\n          p = kp - np;\n          new_element = M.els[i][p] / divisor;\n          els.push(new_element);\n          if (p >= ki) {\n            inverse_elements[i].push(new_element);\n          }\n        }\n        M.els[i] = els;\n        for (j = _i = 0; 0 <= i ? _i < i : _i > i; j = 0 <= i ? ++_i : --_i) {\n          els = [];\n          np = kp;\n          np += 1;\n          while (--np) {\n            p = kp - np;\n            els.push(M.els[j][p] - M.els[i][p] * M.els[j][i]);\n          }\n          M.els[j] = els;\n        }\n      }\n      return new Matrix(inverse_elements);\n    };\n\n    Matrix.I = function(n) {\n      var els, i, j, k, nj;\n      els = [];\n      k = n;\n      n += 1;\n      while (--n) {\n        i = k - n;\n        els[i] = [];\n        nj = k;\n        nj += 1;\n        while (--nj) {\n          j = k - nj;\n          els[i][j] = i === j ? 1 : 0;\n        }\n      }\n      return new Matrix(els);\n    };\n\n    Matrix.prototype.decompose = function() {\n      var els, i, inversePerspectiveMatrix, j, k, matrix, pdum3, perspective, perspectiveMatrix, quaternion, result, rightHandSide, rotate, row, rowElement, s, scale, skew, t, translate, transposedInversePerspectiveMatrix, type, typeKey, v, w, x, y, z, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;\n      matrix = this;\n      translate = [];\n      scale = [];\n      skew = [];\n      quaternion = [];\n      perspective = [];\n      els = [];\n      for (i = _i = 0; _i <= 3; i = ++_i) {\n        els[i] = [];\n        for (j = _j = 0; _j <= 3; j = ++_j) {\n          els[i][j] = matrix.els[i][j];\n        }\n      }\n      if (els[3][3] === 0) {\n        return false;\n      }\n      for (i = _k = 0; _k <= 3; i = ++_k) {\n        for (j = _l = 0; _l <= 3; j = ++_l) {\n          els[i][j] /= els[3][3];\n        }\n      }\n      perspectiveMatrix = matrix.dup();\n      for (i = _m = 0; _m <= 2; i = ++_m) {\n        perspectiveMatrix.els[i][3] = 0;\n      }\n      perspectiveMatrix.els[3][3] = 1;\n      if (els[0][3] !== 0 || els[1][3] !== 0 || els[2][3] !== 0) {\n        rightHandSide = new Vector(els.slice(0, 4)[3]);\n        inversePerspectiveMatrix = perspectiveMatrix.inverse();\n        transposedInversePerspectiveMatrix = inversePerspectiveMatrix.transpose();\n        perspective = transposedInversePerspectiveMatrix.multiply(rightHandSide).els;\n        for (i = _n = 0; _n <= 2; i = ++_n) {\n          els[i][3] = 0;\n        }\n        els[3][3] = 1;\n      } else {\n        perspective = [0, 0, 0, 1];\n      }\n      for (i = _o = 0; _o <= 2; i = ++_o) {\n        translate[i] = els[3][i];\n        els[3][i] = 0;\n      }\n      row = [];\n      for (i = _p = 0; _p <= 2; i = ++_p) {\n        row[i] = new Vector(els[i].slice(0, 3));\n      }\n      scale[0] = row[0].length();\n      row[0] = row[0].normalize();\n      skew[0] = row[0].dot(row[1]);\n      row[1] = row[1].combine(row[0], 1.0, -skew[0]);\n      scale[1] = row[1].length();\n      row[1] = row[1].normalize();\n      skew[0] /= scale[1];\n      skew[1] = row[0].dot(row[2]);\n      row[2] = row[2].combine(row[0], 1.0, -skew[1]);\n      skew[2] = row[1].dot(row[2]);\n      row[2] = row[2].combine(row[1], 1.0, -skew[2]);\n      scale[2] = row[2].length();\n      row[2] = row[2].normalize();\n      skew[1] /= scale[2];\n      skew[2] /= scale[2];\n      pdum3 = row[1].cross(row[2]);\n      if (row[0].dot(pdum3) < 0) {\n        for (i = _q = 0; _q <= 2; i = ++_q) {\n          scale[i] *= -1;\n          for (j = _r = 0; _r <= 2; j = ++_r) {\n            row[i].els[j] *= -1;\n          }\n        }\n      }\n      rowElement = function(index, elementIndex) {\n        return row[index].els[elementIndex];\n      };\n      rotate = [];\n      rotate[1] = Math.asin(-rowElement(0, 2));\n      if (Math.cos(rotate[1]) !== 0) {\n        rotate[0] = Math.atan2(rowElement(1, 2), rowElement(2, 2));\n        rotate[2] = Math.atan2(rowElement(0, 1), rowElement(0, 0));\n      } else {\n        rotate[0] = Math.atan2(-rowElement(2, 0), rowElement(1, 1));\n        rotate[1] = 0;\n      }\n      t = rowElement(0, 0) + rowElement(1, 1) + rowElement(2, 2) + 1.0;\n      if (t > 1e-4) {\n        s = 0.5 / Math.sqrt(t);\n        w = 0.25 / s;\n        x = (rowElement(2, 1) - rowElement(1, 2)) * s;\n        y = (rowElement(0, 2) - rowElement(2, 0)) * s;\n        z = (rowElement(1, 0) - rowElement(0, 1)) * s;\n      } else if ((rowElement(0, 0) > rowElement(1, 1)) && (rowElement(0, 0) > rowElement(2, 2))) {\n        s = Math.sqrt(1.0 + rowElement(0, 0) - rowElement(1, 1) - rowElement(2, 2)) * 2.0;\n        x = 0.25 * s;\n        y = (rowElement(0, 1) + rowElement(1, 0)) / s;\n        z = (rowElement(0, 2) + rowElement(2, 0)) / s;\n        w = (rowElement(2, 1) - rowElement(1, 2)) / s;\n      } else if (rowElement(1, 1) > rowElement(2, 2)) {\n        s = Math.sqrt(1.0 + rowElement(1, 1) - rowElement(0, 0) - rowElement(2, 2)) * 2.0;\n        x = (rowElement(0, 1) + rowElement(1, 0)) / s;\n        y = 0.25 * s;\n        z = (rowElement(1, 2) + rowElement(2, 1)) / s;\n        w = (rowElement(0, 2) - rowElement(2, 0)) / s;\n      } else {\n        s = Math.sqrt(1.0 + rowElement(2, 2) - rowElement(0, 0) - rowElement(1, 1)) * 2.0;\n        x = (rowElement(0, 2) + rowElement(2, 0)) / s;\n        y = (rowElement(1, 2) + rowElement(2, 1)) / s;\n        z = 0.25 * s;\n        w = (rowElement(1, 0) - rowElement(0, 1)) / s;\n      }\n      quaternion = [x, y, z, w];\n      result = new DecomposedMatrix;\n      result.translate = translate;\n      result.scale = scale;\n      result.skew = skew;\n      result.quaternion = quaternion;\n      result.perspective = perspective;\n      result.rotate = rotate;\n      for (typeKey in result) {\n        type = result[typeKey];\n        for (k in type) {\n          v = type[k];\n          if (isNaN(v)) {\n            type[k] = 0;\n          }\n        }\n      }\n      return result;\n    };\n\n    Matrix.prototype.toString = function() {\n      var i, j, str, _i, _j;\n      str = 'matrix3d(';\n      for (i = _i = 0; _i <= 3; i = ++_i) {\n        for (j = _j = 0; _j <= 3; j = ++_j) {\n          str += roundf(this.els[i][j], 10);\n          if (!(i === 3 && j === 3)) {\n            str += ',';\n          }\n        }\n      }\n      str += ')';\n      return str;\n    };\n\n    Matrix.matrixForTransform = cacheFn(function(transform) {\n      var matrixEl, result, style, _ref, _ref1, _ref2;\n      matrixEl = document.createElement('div');\n      matrixEl.style.position = 'absolute';\n      matrixEl.style.visibility = 'hidden';\n      matrixEl.style[propertyWithPrefix(\"transform\")] = transform;\n      document.body.appendChild(matrixEl);\n      style = window.getComputedStyle(matrixEl, null);\n      result = (_ref = (_ref1 = style.transform) != null ? _ref1 : style[propertyWithPrefix(\"transform\")]) != null ? _ref : (_ref2 = dynamics.tests) != null ? _ref2.matrixForTransform(transform) : void 0;\n      document.body.removeChild(matrixEl);\n      return result;\n    });\n\n    Matrix.fromTransform = function(transform) {\n      var digits, elements, i, match, matrixElements, _i;\n      match = transform != null ? transform.match(/matrix3?d?\\(([-0-9,e \\.]*)\\)/) : void 0;\n      if (match) {\n        digits = match[1].split(',');\n        digits = digits.map(parseFloat);\n        if (digits.length === 6) {\n          elements = [digits[0], digits[1], 0, 0, digits[2], digits[3], 0, 0, 0, 0, 1, 0, digits[4], digits[5], 0, 1];\n        } else {\n          elements = digits;\n        }\n      } else {\n        elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n      }\n      matrixElements = [];\n      for (i = _i = 0; _i <= 3; i = ++_i) {\n        matrixElements.push(elements.slice(i * 4, i * 4 + 4));\n      }\n      return new Matrix(matrixElements);\n    };\n\n    return Matrix;\n\n  })();\n\n  prefixFor = cacheFn(function(property) {\n    var k, prefix, prop, propArray, propertyName, _i, _j, _len, _len1, _ref;\n    if (document.body.style[property] !== void 0) {\n      return '';\n    }\n    propArray = property.split('-');\n    propertyName = \"\";\n    for (_i = 0, _len = propArray.length; _i < _len; _i++) {\n      prop = propArray[_i];\n      propertyName += prop.substring(0, 1).toUpperCase() + prop.substring(1);\n    }\n    _ref = [\"Webkit\", \"Moz\", \"ms\"];\n    for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {\n      prefix = _ref[_j];\n      k = prefix + propertyName;\n      if (document.body.style[k] !== void 0) {\n        return prefix;\n      }\n    }\n    return '';\n  });\n\n  propertyWithPrefix = cacheFn(function(property) {\n    var prefix;\n    prefix = prefixFor(property);\n    if (prefix === 'Moz') {\n      return \"\" + prefix + (property.substring(0, 1).toUpperCase() + property.substring(1));\n    }\n    if (prefix !== '') {\n      return \"-\" + (prefix.toLowerCase()) + \"-\" + (toDashed(property));\n    }\n    return toDashed(property);\n  });\n\n  rAF = typeof window !== \"undefined\" && window !== null ? window.requestAnimationFrame : void 0;\n\n  animations = [];\n\n  animationsTimeouts = [];\n\n  slow = false;\n\n  slowRatio = 1;\n\n  if (typeof window !== \"undefined\" && window !== null) {\n    window.addEventListener('keyup', function(e) {\n      if (e.keyCode === 68 && e.shiftKey && e.ctrlKey) {\n        return dynamics.toggleSlow();\n      }\n    });\n  }\n\n  if (rAF == null) {\n    lastTime = 0;\n    rAF = function(callback) {\n      var currTime, id, timeToCall;\n      currTime = Date.now();\n      timeToCall = Math.max(0, 16 - (currTime - lastTime));\n      id = window.setTimeout(function() {\n        return callback(currTime + timeToCall);\n      }, timeToCall);\n      lastTime = currTime + timeToCall;\n      return id;\n    };\n  }\n\n  runLoopRunning = false;\n\n  runLoopPaused = false;\n\n  startRunLoop = function() {\n    if (!runLoopRunning) {\n      runLoopRunning = true;\n      return rAF(runLoopTick);\n    }\n  };\n\n  runLoopTick = function(t) {\n    var animation, toRemoveAnimations, _i, _len;\n    if (runLoopPaused) {\n      rAF(runLoopTick);\n      return;\n    }\n    toRemoveAnimations = [];\n    for (_i = 0, _len = animations.length; _i < _len; _i++) {\n      animation = animations[_i];\n      if (!animationTick(t, animation)) {\n        toRemoveAnimations.push(animation);\n      }\n    }\n    animations = animations.filter(function(animation) {\n      return toRemoveAnimations.indexOf(animation) === -1;\n    });\n    if (animations.length === 0) {\n      return runLoopRunning = false;\n    } else {\n      return rAF(runLoopTick);\n    }\n  };\n\n  animationTick = function(t, animation) {\n    var key, properties, property, tt, y, _base, _base1, _ref;\n    if (animation.tStart == null) {\n      animation.tStart = t;\n    }\n    tt = (t - animation.tStart) / animation.options.duration;\n    y = animation.curve(tt);\n    properties = {};\n    if (tt >= 1) {\n      if (animation.curve.initialForce) {\n        properties = animation.properties.start;\n      } else {\n        properties = animation.properties.end;\n      }\n    } else {\n      _ref = animation.properties.start;\n      for (key in _ref) {\n        property = _ref[key];\n        properties[key] = interpolate(property, animation.properties.end[key], y);\n      }\n    }\n    applyFrame(animation.el, properties);\n    if (typeof (_base = animation.options).change === \"function\") {\n      _base.change(animation.el);\n    }\n    if (tt >= 1) {\n      if (typeof (_base1 = animation.options).complete === \"function\") {\n        _base1.complete(animation.el);\n      }\n    }\n    return tt < 1;\n  };\n\n  interpolate = function(start, end, y) {\n    if ((start != null) && (start.interpolate != null)) {\n      return start.interpolate(end, y);\n    }\n    return null;\n  };\n\n  startAnimation = function(el, properties, options, timeoutId) {\n    var endProperties, isSVG, k, matrix, startProperties, transforms, v, _base;\n    if (timeoutId != null) {\n      animationsTimeouts = animationsTimeouts.filter(function(timeout) {\n        return timeout.id !== timeoutId;\n      });\n    }\n    dynamics.stop(el, {\n      timeout: false\n    });\n    if (!options.animated) {\n      dynamics.css(el, properties);\n      if (typeof options.complete === \"function\") {\n        options.complete(this);\n      }\n      return;\n    }\n    properties = parseProperties(properties);\n    startProperties = getCurrentProperties(el, Object.keys(properties));\n    endProperties = {};\n    transforms = [];\n    for (k in properties) {\n      v = properties[k];\n      if ((el.style != null) && transformProperties.contains(k)) {\n        transforms.push([k, v]);\n      } else {\n        endProperties[k] = createInterpolable(v);\n        if (endProperties[k] instanceof InterpolableWithUnit && (el.style != null)) {\n          endProperties[k].prefix = '';\n          if ((_base = endProperties[k]).suffix == null) {\n            _base.suffix = unitForProperty(k, 0);\n          }\n        }\n      }\n    }\n    if (transforms.length > 0) {\n      isSVG = isSVGElement(el);\n      if (isSVG) {\n        matrix = new Matrix2D();\n        matrix.applyProperties(transforms);\n      } else {\n        v = (transforms.map(function(transform) {\n          return transformValueForProperty(transform[0], transform[1]);\n        })).join(\" \");\n        matrix = Matrix.fromTransform(Matrix.matrixForTransform(v));\n      }\n      endProperties['transform'] = matrix.decompose();\n      if (isSVG) {\n        startProperties.transform.applyRotateCenter([endProperties.transform.props.rotate[1], endProperties.transform.props.rotate[2]]);\n      }\n    }\n    animations.push({\n      el: el,\n      properties: {\n        start: startProperties,\n        end: endProperties\n      },\n      options: options,\n      curve: options.type.call(options.type, options)\n    });\n    return startRunLoop();\n  };\n\n  timeouts = [];\n\n  timeoutLastId = 0;\n\n  setRealTimeout = function(timeout) {\n    if (!isDocumentVisible()) {\n      return;\n    }\n    return timeout.realTimeoutId = setTimeout(function() {\n      timeout.fn();\n      return cancelTimeout(timeout.id);\n    }, timeout.delay);\n  };\n\n  addTimeout = function(fn, delay) {\n    var timeout;\n    timeoutLastId += 1;\n    timeout = {\n      id: timeoutLastId,\n      tStart: Date.now(),\n      fn: fn,\n      delay: delay,\n      originalDelay: delay\n    };\n    setRealTimeout(timeout);\n    timeouts.push(timeout);\n    return timeoutLastId;\n  };\n\n  cancelTimeout = function(id) {\n    return timeouts = timeouts.filter(function(timeout) {\n      if (timeout.id === id) {\n        clearTimeout(timeout.realTimeoutId);\n      }\n      return timeout.id !== id;\n    });\n  };\n\n  leftDelayForTimeout = function(time, timeout) {\n    var consumedDelay;\n    if (time != null) {\n      consumedDelay = time - timeout.tStart;\n      return timeout.originalDelay - consumedDelay;\n    } else {\n      return timeout.originalDelay;\n    }\n  };\n\n  if (typeof window !== \"undefined\" && window !== null) {\n    window.addEventListener('unload', function() {});\n  }\n\n  timeBeforeVisibilityChange = null;\n\n  observeVisibilityChange(function(visible) {\n    var animation, difference, timeout, _i, _j, _k, _len, _len1, _len2, _results;\n    runLoopPaused = !visible;\n    if (!visible) {\n      timeBeforeVisibilityChange = Date.now();\n      _results = [];\n      for (_i = 0, _len = timeouts.length; _i < _len; _i++) {\n        timeout = timeouts[_i];\n        _results.push(clearTimeout(timeout.realTimeoutId));\n      }\n      return _results;\n    } else {\n      if (runLoopRunning) {\n        difference = Date.now() - timeBeforeVisibilityChange;\n        for (_j = 0, _len1 = animations.length; _j < _len1; _j++) {\n          animation = animations[_j];\n          if (animation.tStart != null) {\n            animation.tStart += difference;\n          }\n        }\n      }\n      for (_k = 0, _len2 = timeouts.length; _k < _len2; _k++) {\n        timeout = timeouts[_k];\n        timeout.delay = leftDelayForTimeout(timeBeforeVisibilityChange, timeout);\n        setRealTimeout(timeout);\n      }\n      return timeBeforeVisibilityChange = null;\n    }\n  });\n\n  dynamics = {};\n\n  dynamics.linear = function() {\n    return function(t) {\n      return t;\n    };\n  };\n\n  dynamics.spring = function(options) {\n    var A1, A2, decal, frequency, friction, s;\n    if (options == null) {\n      options = {};\n    }\n    applyDefaults(options, arguments.callee.defaults);\n    frequency = Math.max(1, options.frequency / 20);\n    friction = Math.pow(20, options.friction / 100);\n    s = options.anticipationSize / 1000;\n    decal = Math.max(0, s);\n    A1 = function(t) {\n      var M, a, b, x0, x1;\n      M = 0.8;\n      x0 = s / (1 - s);\n      x1 = 0;\n      b = (x0 - (M * x1)) / (x0 - x1);\n      a = (M - b) / x0;\n      return (a * t * options.anticipationStrength / 100) + b;\n    };\n    A2 = function(t) {\n      return Math.pow(friction / 10, -t) * (1 - t);\n    };\n    return function(t) {\n      var A, At, a, angle, b, frictionT, y0, yS;\n      frictionT = (t / (1 - s)) - (s / (1 - s));\n      if (t < s) {\n        yS = (s / (1 - s)) - (s / (1 - s));\n        y0 = (0 / (1 - s)) - (s / (1 - s));\n        b = Math.acos(1 / A1(yS));\n        a = (Math.acos(1 / A1(y0)) - b) / (frequency * (-s));\n        A = A1;\n      } else {\n        A = A2;\n        b = 0;\n        a = 1;\n      }\n      At = A(frictionT);\n      angle = frequency * (t - s) * a + b;\n      return 1 - (At * Math.cos(angle));\n    };\n  };\n\n  dynamics.bounce = function(options) {\n    var A, fn, frequency, friction;\n    if (options == null) {\n      options = {};\n    }\n    applyDefaults(options, arguments.callee.defaults);\n    frequency = Math.max(1, options.frequency / 20);\n    friction = Math.pow(20, options.friction / 100);\n    A = function(t) {\n      return Math.pow(friction / 10, -t) * (1 - t);\n    };\n    fn = function(t) {\n      var At, a, angle, b;\n      b = -3.14 / 2;\n      a = 1;\n      At = A(t);\n      angle = frequency * t * a + b;\n      return At * Math.cos(angle);\n    };\n    fn.initialForce = true;\n    return fn;\n  };\n\n  dynamics.gravity = function(options) {\n    var L, bounciness, curves, elasticity, fn, getPointInCurve, gravity;\n    if (options == null) {\n      options = {};\n    }\n    applyDefaults(options, arguments.callee.defaults);\n    bounciness = Math.min(options.bounciness / 1250, 0.8);\n    elasticity = options.elasticity / 1000;\n    gravity = 100;\n    curves = [];\n    L = (function() {\n      var b, curve;\n      b = Math.sqrt(2 / gravity);\n      curve = {\n        a: -b,\n        b: b,\n        H: 1\n      };\n      if (options.initialForce) {\n        curve.a = 0;\n        curve.b = curve.b * 2;\n      }\n      while (curve.H > 0.001) {\n        L = curve.b - curve.a;\n        curve = {\n          a: curve.b,\n          b: curve.b + L * bounciness,\n          H: curve.H * bounciness * bounciness\n        };\n      }\n      return curve.b;\n    })();\n    getPointInCurve = function(a, b, H, t) {\n      var c, t2;\n      L = b - a;\n      t2 = (2 / L) * t - 1 - (a * 2 / L);\n      c = t2 * t2 * H - H + 1;\n      if (options.initialForce) {\n        c = 1 - c;\n      }\n      return c;\n    };\n    (function() {\n      var L2, b, curve, _results;\n      b = Math.sqrt(2 / (gravity * L * L));\n      curve = {\n        a: -b,\n        b: b,\n        H: 1\n      };\n      if (options.initialForce) {\n        curve.a = 0;\n        curve.b = curve.b * 2;\n      }\n      curves.push(curve);\n      L2 = L;\n      _results = [];\n      while (curve.b < 1 && curve.H > 0.001) {\n        L2 = curve.b - curve.a;\n        curve = {\n          a: curve.b,\n          b: curve.b + L2 * bounciness,\n          H: curve.H * elasticity\n        };\n        _results.push(curves.push(curve));\n      }\n      return _results;\n    })();\n    fn = function(t) {\n      var curve, i, v;\n      i = 0;\n      curve = curves[i];\n      while (!(t >= curve.a && t <= curve.b)) {\n        i += 1;\n        curve = curves[i];\n        if (!curve) {\n          break;\n        }\n      }\n      if (!curve) {\n        v = options.initialForce ? 0 : 1;\n      } else {\n        v = getPointInCurve(curve.a, curve.b, curve.H, t);\n      }\n      return v;\n    };\n    fn.initialForce = options.initialForce;\n    return fn;\n  };\n\n  dynamics.forceWithGravity = function(options) {\n    if (options == null) {\n      options = {};\n    }\n    applyDefaults(options, arguments.callee.defaults);\n    options.initialForce = true;\n    return dynamics.gravity(options);\n  };\n\n  dynamics.bezier = (function() {\n    var Bezier, Bezier_, yForX;\n    Bezier_ = function(t, p0, p1, p2, p3) {\n      return (Math.pow(1 - t, 3) * p0) + (3 * Math.pow(1 - t, 2) * t * p1) + (3 * (1 - t) * Math.pow(t, 2) * p2) + Math.pow(t, 3) * p3;\n    };\n    Bezier = function(t, p0, p1, p2, p3) {\n      return {\n        x: Bezier_(t, p0.x, p1.x, p2.x, p3.x),\n        y: Bezier_(t, p0.y, p1.y, p2.y, p3.y)\n      };\n    };\n    yForX = function(xTarget, Bs, returnsToSelf) {\n      var B, aB, i, lower, percent, upper, x, xTolerance, _i, _len;\n      B = null;\n      for (_i = 0, _len = Bs.length; _i < _len; _i++) {\n        aB = Bs[_i];\n        if (xTarget >= aB(0).x && xTarget <= aB(1).x) {\n          B = aB;\n        }\n        if (B !== null) {\n          break;\n        }\n      }\n      if (!B) {\n        if (returnsToSelf) {\n          return 0;\n        } else {\n          return 1;\n        }\n      }\n      xTolerance = 0.0001;\n      lower = 0;\n      upper = 1;\n      percent = (upper + lower) / 2;\n      x = B(percent).x;\n      i = 0;\n      while (Math.abs(xTarget - x) > xTolerance && i < 100) {\n        if (xTarget > x) {\n          lower = percent;\n        } else {\n          upper = percent;\n        }\n        percent = (upper + lower) / 2;\n        x = B(percent).x;\n        i += 1;\n      }\n      return B(percent).y;\n    };\n    return function(options) {\n      var Bs, points, returnsToSelf;\n      if (options == null) {\n        options = {};\n      }\n      points = options.points;\n      returnsToSelf = false;\n      Bs = (function() {\n        var i, k, _fn;\n        Bs = [];\n        _fn = function(pointA, pointB) {\n          var B2;\n          B2 = function(t) {\n            return Bezier(t, pointA, pointA.cp[pointA.cp.length - 1], pointB.cp[0], pointB);\n          };\n          return Bs.push(B2);\n        };\n        for (i in points) {\n          k = parseInt(i);\n          if (k >= points.length - 1) {\n            break;\n          }\n          _fn(points[k], points[k + 1]);\n        }\n        return Bs;\n      })();\n      return function(t) {\n        if (t === 0) {\n          return 0;\n        } else if (t === 1) {\n          return 1;\n        } else {\n          return yForX(t, Bs, returnsToSelf);\n        }\n      };\n    };\n  })();\n\n  dynamics.easeInOut = function(options) {\n    var friction, _ref;\n    if (options == null) {\n      options = {};\n    }\n    friction = (_ref = options.friction) != null ? _ref : arguments.callee.defaults.friction;\n    return dynamics.bezier({\n      points: [\n        {\n          x: 0,\n          y: 0,\n          cp: [\n            {\n              x: 0.92 - (friction / 1000),\n              y: 0\n            }\n          ]\n        }, {\n          x: 1,\n          y: 1,\n          cp: [\n            {\n              x: 0.08 + (friction / 1000),\n              y: 1\n            }\n          ]\n        }\n      ]\n    });\n  };\n\n  dynamics.easeIn = function(options) {\n    var friction, _ref;\n    if (options == null) {\n      options = {};\n    }\n    friction = (_ref = options.friction) != null ? _ref : arguments.callee.defaults.friction;\n    return dynamics.bezier({\n      points: [\n        {\n          x: 0,\n          y: 0,\n          cp: [\n            {\n              x: 0.92 - (friction / 1000),\n              y: 0\n            }\n          ]\n        }, {\n          x: 1,\n          y: 1,\n          cp: [\n            {\n              x: 1,\n              y: 1\n            }\n          ]\n        }\n      ]\n    });\n  };\n\n  dynamics.easeOut = function(options) {\n    var friction, _ref;\n    if (options == null) {\n      options = {};\n    }\n    friction = (_ref = options.friction) != null ? _ref : arguments.callee.defaults.friction;\n    return dynamics.bezier({\n      points: [\n        {\n          x: 0,\n          y: 0,\n          cp: [\n            {\n              x: 0,\n              y: 0\n            }\n          ]\n        }, {\n          x: 1,\n          y: 1,\n          cp: [\n            {\n              x: 0.08 + (friction / 1000),\n              y: 1\n            }\n          ]\n        }\n      ]\n    });\n  };\n\n  dynamics.spring.defaults = {\n    frequency: 300,\n    friction: 200,\n    anticipationSize: 0,\n    anticipationStrength: 0\n  };\n\n  dynamics.bounce.defaults = {\n    frequency: 300,\n    friction: 200\n  };\n\n  dynamics.forceWithGravity.defaults = dynamics.gravity.defaults = {\n    bounciness: 400,\n    elasticity: 200\n  };\n\n  dynamics.easeInOut.defaults = dynamics.easeIn.defaults = dynamics.easeOut.defaults = {\n    friction: 500\n  };\n\n  dynamics.css = makeArrayFn(function(el, properties) {\n    return applyProperties(el, properties, true);\n  });\n\n  dynamics.animate = makeArrayFn(function(el, properties, options) {\n    var id;\n    if (options == null) {\n      options = {};\n    }\n    options = clone(options);\n    applyDefaults(options, {\n      type: dynamics.easeInOut,\n      duration: 1000,\n      delay: 0,\n      animated: true\n    });\n    options.duration = Math.max(0, options.duration * slowRatio);\n    options.delay = Math.max(0, options.delay);\n    if (options.delay === 0) {\n      return startAnimation(el, properties, options);\n    } else {\n      id = dynamics.setTimeout(function() {\n        return startAnimation(el, properties, options, id);\n      }, options.delay);\n      return animationsTimeouts.push({\n        id: id,\n        el: el\n      });\n    }\n  });\n\n  dynamics.stop = makeArrayFn(function(el, options) {\n    if (options == null) {\n      options = {};\n    }\n    if (options.timeout == null) {\n      options.timeout = true;\n    }\n    if (options.timeout) {\n      animationsTimeouts = animationsTimeouts.filter(function(timeout) {\n        if (timeout.el === el && ((options.filter == null) || options.filter(timeout))) {\n          dynamics.clearTimeout(timeout.id);\n          return false;\n        }\n        return true;\n      });\n    }\n    return animations = animations.filter(function(animation) {\n      return animation.el !== el;\n    });\n  });\n\n  dynamics.setTimeout = function(fn, delay) {\n    return addTimeout(fn, delay * slowRatio);\n  };\n\n  dynamics.clearTimeout = function(id) {\n    return cancelTimeout(id);\n  };\n\n  dynamics.toggleSlow = function() {\n    slow = !slow;\n    if (slow) {\n      slowRatio = 3;\n    } else {\n      slowRatio = 1;\n    }\n    return typeof console !== \"undefined\" && console !== null ? typeof console.log === \"function\" ? console.log(\"dynamics.js: slow animations \" + (slow ? \"enabled\" : \"disabled\")) : void 0 : void 0;\n  };\n\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    module.exports = dynamics;\n  } else if (typeof define === \"function\") {\n    define('dynamics', function() {\n      return dynamics;\n    });\n  } else {\n    window.dynamics = dynamics;\n  }\n\n}).call(this);\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n// Generated by CoffeeScript 1.7.1\n(function() {\n  var Color, DecomposedMatrix, DecomposedMatrix2D, InterpolableArray, InterpolableColor, InterpolableObject, InterpolableWithUnit, Matrix, Matrix2D, Set, Vector, addTimeout, animationTick, animations, animationsTimeouts, applyDefaults, applyFrame, applyProperties, baseSVG, cacheFn, cancelTimeout, clone, createInterpolable, defaultValueForKey, degProperties, dynamics, getCurrentProperties, interpolate, isDocumentVisible, isSVGElement, lastTime, leftDelayForTimeout, makeArrayFn, observeVisibilityChange, parseProperties, prefixFor, propertyWithPrefix, pxProperties, rAF, roundf, runLoopPaused, runLoopRunning, runLoopTick, setRealTimeout, slow, slowRatio, startAnimation, startRunLoop, svgProperties, timeBeforeVisibilityChange, timeoutLastId, timeouts, toDashed, transformProperties, transformValueForProperty, unitForProperty,\n    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n  isDocumentVisible = function() {\n    return document.visibilityState === \"visible\" || (dynamics.tests != null);\n  };\n\n  observeVisibilityChange = (function() {\n    var fns;\n    fns = [];\n    if (typeof document !== \"undefined\" && document !== null) {\n      document.addEventListener(\"visibilitychange\", function() {\n        var fn, _i, _len, _results;\n        _results = [];\n        for (_i = 0, _len = fns.length; _i < _len; _i++) {\n          fn = fns[_i];\n          _results.push(fn(isDocumentVisible()));\n        }\n        return _results;\n      });\n    }\n    return function(fn) {\n      return fns.push(fn);\n    };\n  })();\n\n  clone = function(o) {\n    var k, newO, v;\n    newO = {};\n    for (k in o) {\n      v = o[k];\n      newO[k] = v;\n    }\n    return newO;\n  };\n\n  cacheFn = function(func) {\n    var data;\n    data = {};\n    return function() {\n      var k, key, result, _i, _len;\n      key = \"\";\n      for (_i = 0, _len = arguments.length; _i < _len; _i++) {\n        k = arguments[_i];\n        key += k.toString() + \",\";\n      }\n      result = data[key];\n      if (!result) {\n        data[key] = result = func.apply(this, arguments);\n      }\n      return result;\n    };\n  };\n\n  makeArrayFn = function(fn) {\n    return function(el) {\n      var args, i, res;\n      if (el instanceof Array || el instanceof NodeList || el instanceof HTMLCollection) {\n        res = (function() {\n          var _i, _ref, _results;\n          _results = [];\n          for (i = _i = 0, _ref = el.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n            args = Array.prototype.slice.call(arguments, 1);\n            args.splice(0, 0, el[i]);\n            _results.push(fn.apply(this, args));\n          }\n          return _results;\n        }).apply(this, arguments);\n        return res;\n      }\n      return fn.apply(this, arguments);\n    };\n  };\n\n  applyDefaults = function(options, defaults) {\n    var k, v, _results;\n    _results = [];\n    for (k in defaults) {\n      v = defaults[k];\n      _results.push(options[k] != null ? options[k] : options[k] = v);\n    }\n    return _results;\n  };\n\n  applyFrame = function(el, properties) {\n    var k, v, _results;\n    if ((el.style != null)) {\n      return applyProperties(el, properties);\n    } else {\n      _results = [];\n      for (k in properties) {\n        v = properties[k];\n        _results.push(el[k] = v.format());\n      }\n      return _results;\n    }\n  };\n\n  applyProperties = function(el, properties) {\n    var isSVG, k, matrix, transforms, v;\n    properties = parseProperties(properties);\n    transforms = [];\n    isSVG = isSVGElement(el);\n    for (k in properties) {\n      v = properties[k];\n      if (transformProperties.contains(k)) {\n        transforms.push([k, v]);\n      } else {\n        if (v.format != null) {\n          v = v.format();\n        } else {\n          v = \"\" + v + (unitForProperty(k, v));\n        }\n        if (isSVG && svgProperties.contains(k)) {\n          el.setAttribute(k, v);\n        } else {\n          el.style[propertyWithPrefix(k)] = v;\n        }\n      }\n    }\n    if (transforms.length > 0) {\n      if (isSVG) {\n        matrix = new Matrix2D();\n        matrix.applyProperties(transforms);\n        return el.setAttribute(\"transform\", matrix.decompose().format());\n      } else {\n        v = (transforms.map(function(transform) {\n          return transformValueForProperty(transform[0], transform[1]);\n        })).join(\" \");\n        return el.style[propertyWithPrefix(\"transform\")] = v;\n      }\n    }\n  };\n\n  isSVGElement = function(el) {\n    var _ref, _ref1;\n    if ((typeof SVGElement !== \"undefined\" && SVGElement !== null) && (typeof SVGSVGElement !== \"undefined\" && SVGSVGElement !== null)) {\n      return el instanceof SVGElement && !(el instanceof SVGSVGElement);\n    } else {\n      return (_ref = (_ref1 = dynamics.tests) != null ? typeof _ref1.isSVG === \"function\" ? _ref1.isSVG(el) : void 0 : void 0) != null ? _ref : false;\n    }\n  };\n\n  roundf = function(v, decimal) {\n    var d;\n    d = Math.pow(10, decimal);\n    return Math.round(v * d) / d;\n  };\n\n  Set = (function() {\n    function Set(array) {\n      var v, _i, _len;\n      this.obj = {};\n      for (_i = 0, _len = array.length; _i < _len; _i++) {\n        v = array[_i];\n        this.obj[v] = 1;\n      }\n    }\n\n    Set.prototype.contains = function(v) {\n      return this.obj[v] === 1;\n    };\n\n    return Set;\n\n  })();\n\n  toDashed = function(str) {\n    return str.replace(/([A-Z])/g, function($1) {\n      return \"-\" + $1.toLowerCase();\n    });\n  };\n\n  pxProperties = new Set('marginTop,marginLeft,marginBottom,marginRight,paddingTop,paddingLeft,paddingBottom,paddingRight,top,left,bottom,right,translateX,translateY,translateZ,perspectiveX,perspectiveY,perspectiveZ,width,height,maxWidth,maxHeight,minWidth,minHeight,borderRadius'.split(','));\n\n  degProperties = new Set('rotate,rotateX,rotateY,rotateZ,skew,skewX,skewY,skewZ'.split(','));\n\n  transformProperties = new Set('translate,translateX,translateY,translateZ,scale,scaleX,scaleY,scaleZ,rotate,rotateX,rotateY,rotateZ,rotateC,rotateCX,rotateCY,skew,skewX,skewY,skewZ,perspective'.split(','));\n\n  svgProperties = new Set('accent-height,ascent,azimuth,baseFrequency,baseline-shift,bias,cx,cy,d,diffuseConstant,divisor,dx,dy,elevation,filterRes,fx,fy,gradientTransform,height,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,letter-spacing,limitingConeAngle,markerHeight,markerWidth,numOctaves,order,overline-position,overline-thickness,pathLength,points,pointsAtX,pointsAtY,pointsAtZ,r,radius,rx,ry,seed,specularConstant,specularExponent,stdDeviation,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,surfaceScale,target,targetX,targetY,transform,underline-position,underline-thickness,viewBox,width,x,x1,x2,y,y1,y2,z'.split(','));\n\n  unitForProperty = function(k, v) {\n    if (typeof v !== 'number') {\n      return '';\n    }\n    if (pxProperties.contains(k)) {\n      return 'px';\n    } else if (degProperties.contains(k)) {\n      return 'deg';\n    }\n    return '';\n  };\n\n  transformValueForProperty = function(k, v) {\n    var match, unit;\n    match = (\"\" + v).match(/^([0-9.-]*)([^0-9]*)$/);\n    if (match != null) {\n      v = match[1];\n      unit = match[2];\n    } else {\n      v = parseFloat(v);\n    }\n    v = roundf(parseFloat(v), 10);\n    if ((unit == null) || unit === \"\") {\n      unit = unitForProperty(k, v);\n    }\n    return \"\" + k + \"(\" + v + unit + \")\";\n  };\n\n  parseProperties = function(properties) {\n    var axis, match, parsed, property, value, _i, _len, _ref;\n    parsed = {};\n    for (property in properties) {\n      value = properties[property];\n      if (transformProperties.contains(property)) {\n        match = property.match(/(translate|rotateC|rotate|skew|scale|perspective)(X|Y|Z|)/);\n        if (match && match[2].length > 0) {\n          parsed[property] = value;\n        } else {\n          _ref = ['X', 'Y', 'Z'];\n          for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n            axis = _ref[_i];\n            parsed[match[1] + axis] = value;\n          }\n        }\n      } else {\n        parsed[property] = value;\n      }\n    }\n    return parsed;\n  };\n\n  defaultValueForKey = function(key) {\n    var v;\n    v = key === 'opacity' ? 1 : 0;\n    return \"\" + v + (unitForProperty(key, v));\n  };\n\n  getCurrentProperties = function(el, keys) {\n    var isSVG, key, matrix, properties, style, v, _i, _j, _len, _len1, _ref;\n    properties = {};\n    isSVG = isSVGElement(el);\n    if (el.style != null) {\n      style = window.getComputedStyle(el, null);\n      for (_i = 0, _len = keys.length; _i < _len; _i++) {\n        key = keys[_i];\n        if (transformProperties.contains(key)) {\n          if (properties['transform'] == null) {\n            if (isSVG) {\n              matrix = new Matrix2D((_ref = el.transform.baseVal.consolidate()) != null ? _ref.matrix : void 0);\n            } else {\n              matrix = Matrix.fromTransform(style[propertyWithPrefix('transform')]);\n            }\n            properties['transform'] = matrix.decompose();\n          }\n        } else {\n          v = style[key];\n          if ((v == null) && svgProperties.contains(key)) {\n            v = el.getAttribute(key);\n          }\n          if (v === \"\" || (v == null)) {\n            v = defaultValueForKey(key);\n          }\n          properties[key] = createInterpolable(v);\n        }\n      }\n    } else {\n      for (_j = 0, _len1 = keys.length; _j < _len1; _j++) {\n        key = keys[_j];\n        properties[key] = createInterpolable(el[key]);\n      }\n    }\n    return properties;\n  };\n\n  createInterpolable = function(value) {\n    var interpolable, klass, klasses, _i, _len;\n    klasses = [InterpolableColor, InterpolableArray, InterpolableObject, InterpolableWithUnit];\n    for (_i = 0, _len = klasses.length; _i < _len; _i++) {\n      klass = klasses[_i];\n      interpolable = klass.create(value);\n      if (interpolable != null) {\n        return interpolable;\n      }\n    }\n    return null;\n  };\n\n  InterpolableObject = (function() {\n    function InterpolableObject(obj) {\n      this.format = __bind(this.format, this);\n      this.interpolate = __bind(this.interpolate, this);\n      this.obj = obj;\n    }\n\n    InterpolableObject.prototype.interpolate = function(endInterpolable, t) {\n      var end, k, newObj, start, v;\n      start = this.obj;\n      end = endInterpolable.obj;\n      newObj = {};\n      for (k in start) {\n        v = start[k];\n        if (v.interpolate != null) {\n          newObj[k] = v.interpolate(end[k], t);\n        } else {\n          newObj[k] = v;\n        }\n      }\n      return new InterpolableObject(newObj);\n    };\n\n    InterpolableObject.prototype.format = function() {\n      return this.obj;\n    };\n\n    InterpolableObject.create = function(value) {\n      var k, obj, v;\n      if (value instanceof Object) {\n        obj = {};\n        for (k in value) {\n          v = value[k];\n          obj[k] = createInterpolable(v);\n        }\n        return new InterpolableObject(obj);\n      }\n      return null;\n    };\n\n    return InterpolableObject;\n\n  })();\n\n  InterpolableWithUnit = (function() {\n    function InterpolableWithUnit(value, prefix, suffix) {\n      this.prefix = prefix;\n      this.suffix = suffix;\n      this.format = __bind(this.format, this);\n      this.interpolate = __bind(this.interpolate, this);\n      this.value = parseFloat(value);\n    }\n\n    InterpolableWithUnit.prototype.interpolate = function(endInterpolable, t) {\n      var end, start;\n      start = this.value;\n      end = endInterpolable.value;\n      return new InterpolableWithUnit((end - start) * t + start, endInterpolable.prefix || this.prefix, endInterpolable.suffix || this.suffix);\n    };\n\n    InterpolableWithUnit.prototype.format = function() {\n      if ((this.prefix == null) && (this.suffix == null)) {\n        return roundf(this.value, 5);\n      }\n      return this.prefix + roundf(this.value, 5) + this.suffix;\n    };\n\n    InterpolableWithUnit.create = function(value) {\n      var match;\n      if (typeof value !== \"string\") {\n        return new InterpolableWithUnit(value);\n      }\n      match = (\"\" + value).match(\"([^0-9.+-]*)([0-9.+-]+)([^0-9.+-]*)\");\n      if (match != null) {\n        return new InterpolableWithUnit(match[2], match[1], match[3]);\n      }\n      return null;\n    };\n\n    return InterpolableWithUnit;\n\n  })();\n\n  InterpolableArray = (function() {\n    function InterpolableArray(values, sep) {\n      this.values = values;\n      this.sep = sep;\n      this.format = __bind(this.format, this);\n      this.interpolate = __bind(this.interpolate, this);\n    }\n\n    InterpolableArray.prototype.interpolate = function(endInterpolable, t) {\n      var end, i, newValues, start, _i, _ref;\n      start = this.values;\n      end = endInterpolable.values;\n      newValues = [];\n      for (i = _i = 0, _ref = Math.min(start.length, end.length); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n        if (start[i].interpolate != null) {\n          newValues.push(start[i].interpolate(end[i], t));\n        } else {\n          newValues.push(start[i]);\n        }\n      }\n      return new InterpolableArray(newValues, this.sep);\n    };\n\n    InterpolableArray.prototype.format = function() {\n      var values;\n      values = this.values.map(function(val) {\n        if (val.format != null) {\n          return val.format();\n        } else {\n          return val;\n        }\n      });\n      if (this.sep != null) {\n        return values.join(this.sep);\n      } else {\n        return values;\n      }\n    };\n\n    InterpolableArray.createFromArray = function(arr, sep) {\n      var values;\n      values = arr.map(function(val) {\n        return createInterpolable(val) || val;\n      });\n      values = values.filter(function(val) {\n        return val != null;\n      });\n      return new InterpolableArray(values, sep);\n    };\n\n    InterpolableArray.create = function(value) {\n      var arr, sep, seps, _i, _len;\n      if (value instanceof Array) {\n        return InterpolableArray.createFromArray(value, null);\n      }\n      if (typeof value !== \"string\") {\n        return;\n      }\n      seps = [' ', ',', '|', ';', '/', ':'];\n      for (_i = 0, _len = seps.length; _i < _len; _i++) {\n        sep = seps[_i];\n        arr = value.split(sep);\n        if (arr.length > 1) {\n          return InterpolableArray.createFromArray(arr, sep);\n        }\n      }\n      return null;\n    };\n\n    return InterpolableArray;\n\n  })();\n\n  Color = (function() {\n    function Color(rgb, format) {\n      this.rgb = rgb != null ? rgb : {};\n      this.format = format;\n      this.toRgba = __bind(this.toRgba, this);\n      this.toRgb = __bind(this.toRgb, this);\n      this.toHex = __bind(this.toHex, this);\n    }\n\n    Color.fromHex = function(hex) {\n      var hex3, result;\n      hex3 = hex.match(/^#([a-f\\d]{1})([a-f\\d]{1})([a-f\\d]{1})$/i);\n      if (hex3 != null) {\n        hex = \"#\" + hex3[1] + hex3[1] + hex3[2] + hex3[2] + hex3[3] + hex3[3];\n      }\n      result = hex.match(/^#([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i);\n      if (result != null) {\n        return new Color({\n          r: parseInt(result[1], 16),\n          g: parseInt(result[2], 16),\n          b: parseInt(result[3], 16),\n          a: 1\n        }, \"hex\");\n      }\n      return null;\n    };\n\n    Color.fromRgb = function(rgb) {\n      var match, _ref;\n      match = rgb.match(/^rgba?\\(([0-9.]*), ?([0-9.]*), ?([0-9.]*)(?:, ?([0-9.]*))?\\)$/);\n      if (match != null) {\n        return new Color({\n          r: parseFloat(match[1]),\n          g: parseFloat(match[2]),\n          b: parseFloat(match[3]),\n          a: parseFloat((_ref = match[4]) != null ? _ref : 1)\n        }, match[4] != null ? \"rgba\" : \"rgb\");\n      }\n      return null;\n    };\n\n    Color.componentToHex = function(c) {\n      var hex;\n      hex = c.toString(16);\n      if (hex.length === 1) {\n        return \"0\" + hex;\n      } else {\n        return hex;\n      }\n    };\n\n    Color.prototype.toHex = function() {\n      return \"#\" + Color.componentToHex(this.rgb.r) + Color.componentToHex(this.rgb.g) + Color.componentToHex(this.rgb.b);\n    };\n\n    Color.prototype.toRgb = function() {\n      return \"rgb(\" + this.rgb.r + \", \" + this.rgb.g + \", \" + this.rgb.b + \")\";\n    };\n\n    Color.prototype.toRgba = function() {\n      return \"rgba(\" + this.rgb.r + \", \" + this.rgb.g + \", \" + this.rgb.b + \", \" + this.rgb.a + \")\";\n    };\n\n    return Color;\n\n  })();\n\n  InterpolableColor = (function() {\n    function InterpolableColor(color) {\n      this.color = color;\n      this.format = __bind(this.format, this);\n      this.interpolate = __bind(this.interpolate, this);\n    }\n\n    InterpolableColor.prototype.interpolate = function(endInterpolable, t) {\n      var end, k, rgb, start, v, _i, _len, _ref;\n      start = this.color;\n      end = endInterpolable.color;\n      rgb = {};\n      _ref = ['r', 'g', 'b'];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        k = _ref[_i];\n        v = Math.round((end.rgb[k] - start.rgb[k]) * t + start.rgb[k]);\n        rgb[k] = Math.min(255, Math.max(0, v));\n      }\n      k = \"a\";\n      v = roundf((end.rgb[k] - start.rgb[k]) * t + start.rgb[k], 5);\n      rgb[k] = Math.min(1, Math.max(0, v));\n      return new InterpolableColor(new Color(rgb, end.format));\n    };\n\n    InterpolableColor.prototype.format = function() {\n      if (this.color.format === \"hex\") {\n        return this.color.toHex();\n      } else if (this.color.format === \"rgb\") {\n        return this.color.toRgb();\n      } else if (this.color.format === \"rgba\") {\n        return this.color.toRgba();\n      }\n    };\n\n    InterpolableColor.create = function(value) {\n      var color;\n      if (typeof value !== \"string\") {\n        return;\n      }\n      color = Color.fromHex(value) || Color.fromRgb(value);\n      if (color != null) {\n        return new InterpolableColor(color);\n      }\n      return null;\n    };\n\n    return InterpolableColor;\n\n  })();\n\n  DecomposedMatrix2D = (function() {\n    function DecomposedMatrix2D(props) {\n      this.props = props;\n      this.applyRotateCenter = __bind(this.applyRotateCenter, this);\n      this.format = __bind(this.format, this);\n      this.interpolate = __bind(this.interpolate, this);\n    }\n\n    DecomposedMatrix2D.prototype.interpolate = function(endMatrix, t) {\n      var i, k, newProps, _i, _j, _k, _l, _len, _len1, _ref, _ref1, _ref2;\n      newProps = {};\n      _ref = ['translate', 'scale', 'rotate'];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        k = _ref[_i];\n        newProps[k] = [];\n        for (i = _j = 0, _ref1 = this.props[k].length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n          newProps[k][i] = (endMatrix.props[k][i] - this.props[k][i]) * t + this.props[k][i];\n        }\n      }\n      for (i = _k = 1; _k <= 2; i = ++_k) {\n        newProps['rotate'][i] = endMatrix.props['rotate'][i];\n      }\n      _ref2 = ['skew'];\n      for (_l = 0, _len1 = _ref2.length; _l < _len1; _l++) {\n        k = _ref2[_l];\n        newProps[k] = (endMatrix.props[k] - this.props[k]) * t + this.props[k];\n      }\n      return new DecomposedMatrix2D(newProps);\n    };\n\n    DecomposedMatrix2D.prototype.format = function() {\n      return \"translate(\" + (this.props.translate.join(',')) + \") rotate(\" + (this.props.rotate.join(',')) + \") skewX(\" + this.props.skew + \") scale(\" + (this.props.scale.join(',')) + \")\";\n    };\n\n    DecomposedMatrix2D.prototype.applyRotateCenter = function(rotateC) {\n      var i, m, m2d, negativeTranslate, _i, _results;\n      m = baseSVG.createSVGMatrix();\n      m = m.translate(rotateC[0], rotateC[1]);\n      m = m.rotate(this.props.rotate[0]);\n      m = m.translate(-rotateC[0], -rotateC[1]);\n      m2d = new Matrix2D(m);\n      negativeTranslate = m2d.decompose().props.translate;\n      _results = [];\n      for (i = _i = 0; _i <= 1; i = ++_i) {\n        _results.push(this.props.translate[i] -= negativeTranslate[i]);\n      }\n      return _results;\n    };\n\n    return DecomposedMatrix2D;\n\n  })();\n\n  baseSVG = typeof document !== \"undefined\" && document !== null ? document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\") : void 0;\n\n  Matrix2D = (function() {\n    function Matrix2D(m) {\n      this.m = m;\n      this.applyProperties = __bind(this.applyProperties, this);\n      this.decompose = __bind(this.decompose, this);\n      if (!this.m) {\n        this.m = baseSVG.createSVGMatrix();\n      }\n    }\n\n    Matrix2D.prototype.decompose = function() {\n      var kx, ky, kz, r0, r1;\n      r0 = new Vector([this.m.a, this.m.b]);\n      r1 = new Vector([this.m.c, this.m.d]);\n      kx = r0.length();\n      kz = r0.dot(r1);\n      r0 = r0.normalize();\n      ky = r1.combine(r0, 1, -kz).length();\n      return new DecomposedMatrix2D({\n        translate: [this.m.e, this.m.f],\n        rotate: [Math.atan2(this.m.b, this.m.a) * 180 / Math.PI, this.rotateCX, this.rotateCY],\n        scale: [kx, ky],\n        skew: kz / ky * 180 / Math.PI\n      });\n    };\n\n    Matrix2D.prototype.applyProperties = function(properties) {\n      var hash, k, props, v, _i, _len, _ref, _ref1;\n      hash = {};\n      for (_i = 0, _len = properties.length; _i < _len; _i++) {\n        props = properties[_i];\n        hash[props[0]] = props[1];\n      }\n      for (k in hash) {\n        v = hash[k];\n        if (k === \"translateX\") {\n          this.m = this.m.translate(v, 0);\n        } else if (k === \"translateY\") {\n          this.m = this.m.translate(0, v);\n        } else if (k === \"scaleX\") {\n          this.m = this.m.scale(v, 1);\n        } else if (k === \"scaleY\") {\n          this.m = this.m.scale(1, v);\n        } else if (k === \"rotateZ\") {\n          this.m = this.m.rotate(v);\n        } else if (k === \"skewX\") {\n          this.m = this.m.skewX(v);\n        } else if (k === \"skewY\") {\n          this.m = this.m.skewY(v);\n        }\n      }\n      this.rotateCX = (_ref = hash.rotateCX) != null ? _ref : 0;\n      return this.rotateCY = (_ref1 = hash.rotateCY) != null ? _ref1 : 0;\n    };\n\n    return Matrix2D;\n\n  })();\n\n  Vector = (function() {\n    function Vector(els) {\n      this.els = els;\n      this.combine = __bind(this.combine, this);\n      this.normalize = __bind(this.normalize, this);\n      this.length = __bind(this.length, this);\n      this.cross = __bind(this.cross, this);\n      this.dot = __bind(this.dot, this);\n      this.e = __bind(this.e, this);\n    }\n\n    Vector.prototype.e = function(i) {\n      if (i < 1 || i > this.els.length) {\n        return null;\n      } else {\n        return this.els[i - 1];\n      }\n    };\n\n    Vector.prototype.dot = function(vector) {\n      var V, n, product;\n      V = vector.els || vector;\n      product = 0;\n      n = this.els.length;\n      if (n !== V.length) {\n        return null;\n      }\n      n += 1;\n      while (--n) {\n        product += this.els[n - 1] * V[n - 1];\n      }\n      return product;\n    };\n\n    Vector.prototype.cross = function(vector) {\n      var A, B;\n      B = vector.els || vector;\n      if (this.els.length !== 3 || B.length !== 3) {\n        return null;\n      }\n      A = this.els;\n      return new Vector([(A[1] * B[2]) - (A[2] * B[1]), (A[2] * B[0]) - (A[0] * B[2]), (A[0] * B[1]) - (A[1] * B[0])]);\n    };\n\n    Vector.prototype.length = function() {\n      var a, e, _i, _len, _ref;\n      a = 0;\n      _ref = this.els;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        e = _ref[_i];\n        a += Math.pow(e, 2);\n      }\n      return Math.sqrt(a);\n    };\n\n    Vector.prototype.normalize = function() {\n      var e, i, length, newElements, _ref;\n      length = this.length();\n      newElements = [];\n      _ref = this.els;\n      for (i in _ref) {\n        e = _ref[i];\n        newElements[i] = e / length;\n      }\n      return new Vector(newElements);\n    };\n\n    Vector.prototype.combine = function(b, ascl, bscl) {\n      var i, result, _i, _ref;\n      result = [];\n      for (i = _i = 0, _ref = this.els.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n        result[i] = (ascl * this.els[i]) + (bscl * b.els[i]);\n      }\n      return new Vector(result);\n    };\n\n    return Vector;\n\n  })();\n\n  DecomposedMatrix = (function() {\n    function DecomposedMatrix() {\n      this.toMatrix = __bind(this.toMatrix, this);\n      this.format = __bind(this.format, this);\n      this.interpolate = __bind(this.interpolate, this);\n    }\n\n    DecomposedMatrix.prototype.interpolate = function(decomposedB, t, only) {\n      var angle, decomposed, decomposedA, i, invscale, invth, k, qa, qb, scale, th, _i, _j, _k, _l, _len, _ref, _ref1;\n      if (only == null) {\n        only = null;\n      }\n      decomposedA = this;\n      decomposed = new DecomposedMatrix;\n      _ref = ['translate', 'scale', 'skew', 'perspective'];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        k = _ref[_i];\n        decomposed[k] = [];\n        for (i = _j = 0, _ref1 = decomposedA[k].length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n          if ((only == null) || only.indexOf(k) > -1 || only.indexOf(\"\" + k + ['x', 'y', 'z'][i]) > -1) {\n            decomposed[k][i] = (decomposedB[k][i] - decomposedA[k][i]) * t + decomposedA[k][i];\n          } else {\n            decomposed[k][i] = decomposedA[k][i];\n          }\n        }\n      }\n      if ((only == null) || only.indexOf('rotate') !== -1) {\n        qa = decomposedA.quaternion;\n        qb = decomposedB.quaternion;\n        angle = qa[0] * qb[0] + qa[1] * qb[1] + qa[2] * qb[2] + qa[3] * qb[3];\n        if (angle < 0.0) {\n          for (i = _k = 0; _k <= 3; i = ++_k) {\n            qa[i] = -qa[i];\n          }\n          angle = -angle;\n        }\n        if (angle + 1.0 > .05) {\n          if (1.0 - angle >= .05) {\n            th = Math.acos(angle);\n            invth = 1.0 / Math.sin(th);\n            scale = Math.sin(th * (1.0 - t)) * invth;\n            invscale = Math.sin(th * t) * invth;\n          } else {\n            scale = 1.0 - t;\n            invscale = t;\n          }\n        } else {\n          qb[0] = -qa[1];\n          qb[1] = qa[0];\n          qb[2] = -qa[3];\n          qb[3] = qa[2];\n          scale = Math.sin(piDouble * (.5 - t));\n          invscale = Math.sin(piDouble * t);\n        }\n        decomposed.quaternion = [];\n        for (i = _l = 0; _l <= 3; i = ++_l) {\n          decomposed.quaternion[i] = qa[i] * scale + qb[i] * invscale;\n        }\n      } else {\n        decomposed.quaternion = decomposedA.quaternion;\n      }\n      return decomposed;\n    };\n\n    DecomposedMatrix.prototype.format = function() {\n      return this.toMatrix().toString();\n    };\n\n    DecomposedMatrix.prototype.toMatrix = function() {\n      var decomposedMatrix, i, j, match, matrix, quaternion, skew, temp, w, x, y, z, _i, _j, _k, _l;\n      decomposedMatrix = this;\n      matrix = Matrix.I(4);\n      for (i = _i = 0; _i <= 3; i = ++_i) {\n        matrix.els[i][3] = decomposedMatrix.perspective[i];\n      }\n      quaternion = decomposedMatrix.quaternion;\n      x = quaternion[0];\n      y = quaternion[1];\n      z = quaternion[2];\n      w = quaternion[3];\n      skew = decomposedMatrix.skew;\n      match = [[1, 0], [2, 0], [2, 1]];\n      for (i = _j = 2; _j >= 0; i = --_j) {\n        if (skew[i]) {\n          temp = Matrix.I(4);\n          temp.els[match[i][0]][match[i][1]] = skew[i];\n          matrix = matrix.multiply(temp);\n        }\n      }\n      matrix = matrix.multiply(new Matrix([[1 - 2 * (y * y + z * z), 2 * (x * y - z * w), 2 * (x * z + y * w), 0], [2 * (x * y + z * w), 1 - 2 * (x * x + z * z), 2 * (y * z - x * w), 0], [2 * (x * z - y * w), 2 * (y * z + x * w), 1 - 2 * (x * x + y * y), 0], [0, 0, 0, 1]]));\n      for (i = _k = 0; _k <= 2; i = ++_k) {\n        for (j = _l = 0; _l <= 2; j = ++_l) {\n          matrix.els[i][j] *= decomposedMatrix.scale[i];\n        }\n        matrix.els[3][i] = decomposedMatrix.translate[i];\n      }\n      return matrix;\n    };\n\n    return DecomposedMatrix;\n\n  })();\n\n  Matrix = (function() {\n    function Matrix(els) {\n      this.els = els;\n      this.toString = __bind(this.toString, this);\n      this.decompose = __bind(this.decompose, this);\n      this.inverse = __bind(this.inverse, this);\n      this.augment = __bind(this.augment, this);\n      this.toRightTriangular = __bind(this.toRightTriangular, this);\n      this.transpose = __bind(this.transpose, this);\n      this.multiply = __bind(this.multiply, this);\n      this.dup = __bind(this.dup, this);\n      this.e = __bind(this.e, this);\n    }\n\n    Matrix.prototype.e = function(i, j) {\n      if (i < 1 || i > this.els.length || j < 1 || j > this.els[0].length) {\n        return null;\n      }\n      return this.els[i - 1][j - 1];\n    };\n\n    Matrix.prototype.dup = function() {\n      return new Matrix(this.els);\n    };\n\n    Matrix.prototype.multiply = function(matrix) {\n      var M, c, cols, elements, i, j, ki, kj, nc, ni, nj, returnVector, sum;\n      returnVector = matrix.modulus ? true : false;\n      M = matrix.els || matrix;\n      if (typeof M[0][0] === 'undefined') {\n        M = new Matrix(M).els;\n      }\n      ni = this.els.length;\n      ki = ni;\n      kj = M[0].length;\n      cols = this.els[0].length;\n      elements = [];\n      ni += 1;\n      while (--ni) {\n        i = ki - ni;\n        elements[i] = [];\n        nj = kj;\n        nj += 1;\n        while (--nj) {\n          j = kj - nj;\n          sum = 0;\n          nc = cols;\n          nc += 1;\n          while (--nc) {\n            c = cols - nc;\n            sum += this.els[i][c] * M[c][j];\n          }\n          elements[i][j] = sum;\n        }\n      }\n      M = new Matrix(elements);\n      if (returnVector) {\n        return M.col(1);\n      } else {\n        return M;\n      }\n    };\n\n    Matrix.prototype.transpose = function() {\n      var cols, elements, i, j, ni, nj, rows;\n      rows = this.els.length;\n      cols = this.els[0].length;\n      elements = [];\n      ni = cols;\n      ni += 1;\n      while (--ni) {\n        i = cols - ni;\n        elements[i] = [];\n        nj = rows;\n        nj += 1;\n        while (--nj) {\n          j = rows - nj;\n          elements[i][j] = this.els[j][i];\n        }\n      }\n      return new Matrix(elements);\n    };\n\n    Matrix.prototype.toRightTriangular = function() {\n      var M, els, i, j, k, kp, multiplier, n, np, p, _i, _j, _ref, _ref1;\n      M = this.dup();\n      n = this.els.length;\n      k = n;\n      kp = this.els[0].length;\n      while (--n) {\n        i = k - n;\n        if (M.els[i][i] === 0) {\n          for (j = _i = _ref = i + 1; _ref <= k ? _i < k : _i > k; j = _ref <= k ? ++_i : --_i) {\n            if (M.els[j][i] !== 0) {\n              els = [];\n              np = kp;\n              np += 1;\n              while (--np) {\n                p = kp - np;\n                els.push(M.els[i][p] + M.els[j][p]);\n              }\n              M.els[i] = els;\n              break;\n            }\n          }\n        }\n        if (M.els[i][i] !== 0) {\n          for (j = _j = _ref1 = i + 1; _ref1 <= k ? _j < k : _j > k; j = _ref1 <= k ? ++_j : --_j) {\n            multiplier = M.els[j][i] / M.els[i][i];\n            els = [];\n            np = kp;\n            np += 1;\n            while (--np) {\n              p = kp - np;\n              els.push(p <= i ? 0 : M.els[j][p] - M.els[i][p] * multiplier);\n            }\n            M.els[j] = els;\n          }\n        }\n      }\n      return M;\n    };\n\n    Matrix.prototype.augment = function(matrix) {\n      var M, T, cols, i, j, ki, kj, ni, nj;\n      M = matrix.els || matrix;\n      if (typeof M[0][0] === 'undefined') {\n        M = new Matrix(M).els;\n      }\n      T = this.dup();\n      cols = T.els[0].length;\n      ni = T.els.length;\n      ki = ni;\n      kj = M[0].length;\n      if (ni !== M.length) {\n        return null;\n      }\n      ni += 1;\n      while (--ni) {\n        i = ki - ni;\n        nj = kj;\n        nj += 1;\n        while (--nj) {\n          j = kj - nj;\n          T.els[i][cols + j] = M[i][j];\n        }\n      }\n      return T;\n    };\n\n    Matrix.prototype.inverse = function() {\n      var M, divisor, els, i, inverse_elements, j, ki, kp, new_element, ni, np, p, _i;\n      ni = this.els.length;\n      ki = ni;\n      M = this.augment(Matrix.I(ni)).toRightTriangular();\n      kp = M.els[0].length;\n      inverse_elements = [];\n      ni += 1;\n      while (--ni) {\n        i = ni - 1;\n        els = [];\n        np = kp;\n        inverse_elements[i] = [];\n        divisor = M.els[i][i];\n        np += 1;\n        while (--np) {\n          p = kp - np;\n          new_element = M.els[i][p] / divisor;\n          els.push(new_element);\n          if (p >= ki) {\n            inverse_elements[i].push(new_element);\n          }\n        }\n        M.els[i] = els;\n        for (j = _i = 0; 0 <= i ? _i < i : _i > i; j = 0 <= i ? ++_i : --_i) {\n          els = [];\n          np = kp;\n          np += 1;\n          while (--np) {\n            p = kp - np;\n            els.push(M.els[j][p] - M.els[i][p] * M.els[j][i]);\n          }\n          M.els[j] = els;\n        }\n      }\n      return new Matrix(inverse_elements);\n    };\n\n    Matrix.I = function(n) {\n      var els, i, j, k, nj;\n      els = [];\n      k = n;\n      n += 1;\n      while (--n) {\n        i = k - n;\n        els[i] = [];\n        nj = k;\n        nj += 1;\n        while (--nj) {\n          j = k - nj;\n          els[i][j] = i === j ? 1 : 0;\n        }\n      }\n      return new Matrix(els);\n    };\n\n    Matrix.prototype.decompose = function() {\n      var els, i, inversePerspectiveMatrix, j, k, matrix, pdum3, perspective, perspectiveMatrix, quaternion, result, rightHandSide, rotate, row, rowElement, s, scale, skew, t, translate, transposedInversePerspectiveMatrix, type, typeKey, v, w, x, y, z, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;\n      matrix = this;\n      translate = [];\n      scale = [];\n      skew = [];\n      quaternion = [];\n      perspective = [];\n      els = [];\n      for (i = _i = 0; _i <= 3; i = ++_i) {\n        els[i] = [];\n        for (j = _j = 0; _j <= 3; j = ++_j) {\n          els[i][j] = matrix.els[i][j];\n        }\n      }\n      if (els[3][3] === 0) {\n        return false;\n      }\n      for (i = _k = 0; _k <= 3; i = ++_k) {\n        for (j = _l = 0; _l <= 3; j = ++_l) {\n          els[i][j] /= els[3][3];\n        }\n      }\n      perspectiveMatrix = matrix.dup();\n      for (i = _m = 0; _m <= 2; i = ++_m) {\n        perspectiveMatrix.els[i][3] = 0;\n      }\n      perspectiveMatrix.els[3][3] = 1;\n      if (els[0][3] !== 0 || els[1][3] !== 0 || els[2][3] !== 0) {\n        rightHandSide = new Vector(els.slice(0, 4)[3]);\n        inversePerspectiveMatrix = perspectiveMatrix.inverse();\n        transposedInversePerspectiveMatrix = inversePerspectiveMatrix.transpose();\n        perspective = transposedInversePerspectiveMatrix.multiply(rightHandSide).els;\n        for (i = _n = 0; _n <= 2; i = ++_n) {\n          els[i][3] = 0;\n        }\n        els[3][3] = 1;\n      } else {\n        perspective = [0, 0, 0, 1];\n      }\n      for (i = _o = 0; _o <= 2; i = ++_o) {\n        translate[i] = els[3][i];\n        els[3][i] = 0;\n      }\n      row = [];\n      for (i = _p = 0; _p <= 2; i = ++_p) {\n        row[i] = new Vector(els[i].slice(0, 3));\n      }\n      scale[0] = row[0].length();\n      row[0] = row[0].normalize();\n      skew[0] = row[0].dot(row[1]);\n      row[1] = row[1].combine(row[0], 1.0, -skew[0]);\n      scale[1] = row[1].length();\n      row[1] = row[1].normalize();\n      skew[0] /= scale[1];\n      skew[1] = row[0].dot(row[2]);\n      row[2] = row[2].combine(row[0], 1.0, -skew[1]);\n      skew[2] = row[1].dot(row[2]);\n      row[2] = row[2].combine(row[1], 1.0, -skew[2]);\n      scale[2] = row[2].length();\n      row[2] = row[2].normalize();\n      skew[1] /= scale[2];\n      skew[2] /= scale[2];\n      pdum3 = row[1].cross(row[2]);\n      if (row[0].dot(pdum3) < 0) {\n        for (i = _q = 0; _q <= 2; i = ++_q) {\n          scale[i] *= -1;\n          for (j = _r = 0; _r <= 2; j = ++_r) {\n            row[i].els[j] *= -1;\n          }\n        }\n      }\n      rowElement = function(index, elementIndex) {\n        return row[index].els[elementIndex];\n      };\n      rotate = [];\n      rotate[1] = Math.asin(-rowElement(0, 2));\n      if (Math.cos(rotate[1]) !== 0) {\n        rotate[0] = Math.atan2(rowElement(1, 2), rowElement(2, 2));\n        rotate[2] = Math.atan2(rowElement(0, 1), rowElement(0, 0));\n      } else {\n        rotate[0] = Math.atan2(-rowElement(2, 0), rowElement(1, 1));\n        rotate[1] = 0;\n      }\n      t = rowElement(0, 0) + rowElement(1, 1) + rowElement(2, 2) + 1.0;\n      if (t > 1e-4) {\n        s = 0.5 / Math.sqrt(t);\n        w = 0.25 / s;\n        x = (rowElement(2, 1) - rowElement(1, 2)) * s;\n        y = (rowElement(0, 2) - rowElement(2, 0)) * s;\n        z = (rowElement(1, 0) - rowElement(0, 1)) * s;\n      } else if ((rowElement(0, 0) > rowElement(1, 1)) && (rowElement(0, 0) > rowElement(2, 2))) {\n        s = Math.sqrt(1.0 + rowElement(0, 0) - rowElement(1, 1) - rowElement(2, 2)) * 2.0;\n        x = 0.25 * s;\n        y = (rowElement(0, 1) + rowElement(1, 0)) / s;\n        z = (rowElement(0, 2) + rowElement(2, 0)) / s;\n        w = (rowElement(2, 1) - rowElement(1, 2)) / s;\n      } else if (rowElement(1, 1) > rowElement(2, 2)) {\n        s = Math.sqrt(1.0 + rowElement(1, 1) - rowElement(0, 0) - rowElement(2, 2)) * 2.0;\n        x = (rowElement(0, 1) + rowElement(1, 0)) / s;\n        y = 0.25 * s;\n        z = (rowElement(1, 2) + rowElement(2, 1)) / s;\n        w = (rowElement(0, 2) - rowElement(2, 0)) / s;\n      } else {\n        s = Math.sqrt(1.0 + rowElement(2, 2) - rowElement(0, 0) - rowElement(1, 1)) * 2.0;\n        x = (rowElement(0, 2) + rowElement(2, 0)) / s;\n        y = (rowElement(1, 2) + rowElement(2, 1)) / s;\n        z = 0.25 * s;\n        w = (rowElement(1, 0) - rowElement(0, 1)) / s;\n      }\n      quaternion = [x, y, z, w];\n      result = new DecomposedMatrix;\n      result.translate = translate;\n      result.scale = scale;\n      result.skew = skew;\n      result.quaternion = quaternion;\n      result.perspective = perspective;\n      result.rotate = rotate;\n      for (typeKey in result) {\n        type = result[typeKey];\n        for (k in type) {\n          v = type[k];\n          if (isNaN(v)) {\n            type[k] = 0;\n          }\n        }\n      }\n      return result;\n    };\n\n    Matrix.prototype.toString = function() {\n      var i, j, str, _i, _j;\n      str = 'matrix3d(';\n      for (i = _i = 0; _i <= 3; i = ++_i) {\n        for (j = _j = 0; _j <= 3; j = ++_j) {\n          str += roundf(this.els[i][j], 10);\n          if (!(i === 3 && j === 3)) {\n            str += ',';\n          }\n        }\n      }\n      str += ')';\n      return str;\n    };\n\n    Matrix.matrixForTransform = cacheFn(function(transform) {\n      var matrixEl, result, style, _ref, _ref1, _ref2;\n      matrixEl = document.createElement('div');\n      matrixEl.style.position = 'absolute';\n      matrixEl.style.visibility = 'hidden';\n      matrixEl.style[propertyWithPrefix(\"transform\")] = transform;\n      document.body.appendChild(matrixEl);\n      style = window.getComputedStyle(matrixEl, null);\n      result = (_ref = (_ref1 = style.transform) != null ? _ref1 : style[propertyWithPrefix(\"transform\")]) != null ? _ref : (_ref2 = dynamics.tests) != null ? _ref2.matrixForTransform(transform) : void 0;\n      document.body.removeChild(matrixEl);\n      return result;\n    });\n\n    Matrix.fromTransform = function(transform) {\n      var digits, elements, i, match, matrixElements, _i;\n      match = transform != null ? transform.match(/matrix3?d?\\(([-0-9,e \\.]*)\\)/) : void 0;\n      if (match) {\n        digits = match[1].split(',');\n        digits = digits.map(parseFloat);\n        if (digits.length === 6) {\n          elements = [digits[0], digits[1], 0, 0, digits[2], digits[3], 0, 0, 0, 0, 1, 0, digits[4], digits[5], 0, 1];\n        } else {\n          elements = digits;\n        }\n      } else {\n        elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n      }\n      matrixElements = [];\n      for (i = _i = 0; _i <= 3; i = ++_i) {\n        matrixElements.push(elements.slice(i * 4, i * 4 + 4));\n      }\n      return new Matrix(matrixElements);\n    };\n\n    return Matrix;\n\n  })();\n\n  prefixFor = cacheFn(function(property) {\n    var k, prefix, prop, propArray, propertyName, _i, _j, _len, _len1, _ref;\n    if (document.body.style[property] !== void 0) {\n      return '';\n    }\n    propArray = property.split('-');\n    propertyName = \"\";\n    for (_i = 0, _len = propArray.length; _i < _len; _i++) {\n      prop = propArray[_i];\n      propertyName += prop.substring(0, 1).toUpperCase() + prop.substring(1);\n    }\n    _ref = [\"Webkit\", \"Moz\", \"ms\"];\n    for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {\n      prefix = _ref[_j];\n      k = prefix + propertyName;\n      if (document.body.style[k] !== void 0) {\n        return prefix;\n      }\n    }\n    return '';\n  });\n\n  propertyWithPrefix = cacheFn(function(property) {\n    var prefix;\n    prefix = prefixFor(property);\n    if (prefix === 'Moz') {\n      return \"\" + prefix + (property.substring(0, 1).toUpperCase() + property.substring(1));\n    }\n    if (prefix !== '') {\n      return \"-\" + (prefix.toLowerCase()) + \"-\" + (toDashed(property));\n    }\n    return toDashed(property);\n  });\n\n  rAF = typeof window !== \"undefined\" && window !== null ? window.requestAnimationFrame : void 0;\n\n  animations = [];\n\n  animationsTimeouts = [];\n\n  slow = false;\n\n  slowRatio = 1;\n\n  if (typeof window !== \"undefined\" && window !== null) {\n    window.addEventListener('keyup', function(e) {\n      if (e.keyCode === 68 && e.shiftKey && e.ctrlKey) {\n        return dynamics.toggleSlow();\n      }\n    });\n  }\n\n  if (rAF == null) {\n    lastTime = 0;\n    rAF = function(callback) {\n      var currTime, id, timeToCall;\n      currTime = Date.now();\n      timeToCall = Math.max(0, 16 - (currTime - lastTime));\n      id = window.setTimeout(function() {\n        return callback(currTime + timeToCall);\n      }, timeToCall);\n      lastTime = currTime + timeToCall;\n      return id;\n    };\n  }\n\n  runLoopRunning = false;\n\n  runLoopPaused = false;\n\n  startRunLoop = function() {\n    if (!runLoopRunning) {\n      runLoopRunning = true;\n      return rAF(runLoopTick);\n    }\n  };\n\n  runLoopTick = function(t) {\n    var animation, toRemoveAnimations, _i, _len;\n    if (runLoopPaused) {\n      rAF(runLoopTick);\n      return;\n    }\n    toRemoveAnimations = [];\n    for (_i = 0, _len = animations.length; _i < _len; _i++) {\n      animation = animations[_i];\n      if (!animationTick(t, animation)) {\n        toRemoveAnimations.push(animation);\n      }\n    }\n    animations = animations.filter(function(animation) {\n      return toRemoveAnimations.indexOf(animation) === -1;\n    });\n    if (animations.length === 0) {\n      return runLoopRunning = false;\n    } else {\n      return rAF(runLoopTick);\n    }\n  };\n\n  animationTick = function(t, animation) {\n    var key, properties, property, tt, y, _base, _base1, _ref;\n    if (animation.tStart == null) {\n      animation.tStart = t;\n    }\n    tt = (t - animation.tStart) / animation.options.duration;\n    y = animation.curve(tt);\n    properties = {};\n    if (tt >= 1) {\n      if (animation.curve.initialForce) {\n        properties = animation.properties.start;\n      } else {\n        properties = animation.properties.end;\n      }\n    } else {\n      _ref = animation.properties.start;\n      for (key in _ref) {\n        property = _ref[key];\n        properties[key] = interpolate(property, animation.properties.end[key], y);\n      }\n    }\n    applyFrame(animation.el, properties);\n    if (typeof (_base = animation.options).change === \"function\") {\n      _base.change(animation.el);\n    }\n    if (tt >= 1) {\n      if (typeof (_base1 = animation.options).complete === \"function\") {\n        _base1.complete(animation.el);\n      }\n    }\n    return tt < 1;\n  };\n\n  interpolate = function(start, end, y) {\n    if ((start != null) && (start.interpolate != null)) {\n      return start.interpolate(end, y);\n    }\n    return null;\n  };\n\n  startAnimation = function(el, properties, options, timeoutId) {\n    var endProperties, isSVG, k, matrix, startProperties, transforms, v, _base;\n    if (timeoutId != null) {\n      animationsTimeouts = animationsTimeouts.filter(function(timeout) {\n        return timeout.id !== timeoutId;\n      });\n    }\n    dynamics.stop(el, {\n      timeout: false\n    });\n    if (!options.animated) {\n      dynamics.css(el, properties);\n      if (typeof options.complete === \"function\") {\n        options.complete(this);\n      }\n      return;\n    }\n    properties = parseProperties(properties);\n    startProperties = getCurrentProperties(el, Object.keys(properties));\n    endProperties = {};\n    transforms = [];\n    for (k in properties) {\n      v = properties[k];\n      if ((el.style != null) && transformProperties.contains(k)) {\n        transforms.push([k, v]);\n      } else {\n        endProperties[k] = createInterpolable(v);\n        if (endProperties[k] instanceof InterpolableWithUnit && (el.style != null)) {\n          endProperties[k].prefix = '';\n          if ((_base = endProperties[k]).suffix == null) {\n            _base.suffix = unitForProperty(k, 0);\n          }\n        }\n      }\n    }\n    if (transforms.length > 0) {\n      isSVG = isSVGElement(el);\n      if (isSVG) {\n        matrix = new Matrix2D();\n        matrix.applyProperties(transforms);\n      } else {\n        v = (transforms.map(function(transform) {\n          return transformValueForProperty(transform[0], transform[1]);\n        })).join(\" \");\n        matrix = Matrix.fromTransform(Matrix.matrixForTransform(v));\n      }\n      endProperties['transform'] = matrix.decompose();\n      if (isSVG) {\n        startProperties.transform.applyRotateCenter([endProperties.transform.props.rotate[1], endProperties.transform.props.rotate[2]]);\n      }\n    }\n    animations.push({\n      el: el,\n      properties: {\n        start: startProperties,\n        end: endProperties\n      },\n      options: options,\n      curve: options.type.call(options.type, options)\n    });\n    return startRunLoop();\n  };\n\n  timeouts = [];\n\n  timeoutLastId = 0;\n\n  setRealTimeout = function(timeout) {\n    if (!isDocumentVisible()) {\n      return;\n    }\n    return timeout.realTimeoutId = setTimeout(function() {\n      timeout.fn();\n      return cancelTimeout(timeout.id);\n    }, timeout.delay);\n  };\n\n  addTimeout = function(fn, delay) {\n    var timeout;\n    timeoutLastId += 1;\n    timeout = {\n      id: timeoutLastId,\n      tStart: Date.now(),\n      fn: fn,\n      delay: delay,\n      originalDelay: delay\n    };\n    setRealTimeout(timeout);\n    timeouts.push(timeout);\n    return timeoutLastId;\n  };\n\n  cancelTimeout = function(id) {\n    return timeouts = timeouts.filter(function(timeout) {\n      if (timeout.id === id) {\n        clearTimeout(timeout.realTimeoutId);\n      }\n      return timeout.id !== id;\n    });\n  };\n\n  leftDelayForTimeout = function(time, timeout) {\n    var consumedDelay;\n    if (time != null) {\n      consumedDelay = time - timeout.tStart;\n      return timeout.originalDelay - consumedDelay;\n    } else {\n      return timeout.originalDelay;\n    }\n  };\n\n  if (typeof window !== \"undefined\" && window !== null) {\n    window.addEventListener('unload', function() {});\n  }\n\n  timeBeforeVisibilityChange = null;\n\n  observeVisibilityChange(function(visible) {\n    var animation, difference, timeout, _i, _j, _k, _len, _len1, _len2, _results;\n    runLoopPaused = !visible;\n    if (!visible) {\n      timeBeforeVisibilityChange = Date.now();\n      _results = [];\n      for (_i = 0, _len = timeouts.length; _i < _len; _i++) {\n        timeout = timeouts[_i];\n        _results.push(clearTimeout(timeout.realTimeoutId));\n      }\n      return _results;\n    } else {\n      if (runLoopRunning) {\n        difference = Date.now() - timeBeforeVisibilityChange;\n        for (_j = 0, _len1 = animations.length; _j < _len1; _j++) {\n          animation = animations[_j];\n          if (animation.tStart != null) {\n            animation.tStart += difference;\n          }\n        }\n      }\n      for (_k = 0, _len2 = timeouts.length; _k < _len2; _k++) {\n        timeout = timeouts[_k];\n        timeout.delay = leftDelayForTimeout(timeBeforeVisibilityChange, timeout);\n        setRealTimeout(timeout);\n      }\n      return timeBeforeVisibilityChange = null;\n    }\n  });\n\n  dynamics = {};\n\n  dynamics.linear = function() {\n    return function(t) {\n      return t;\n    };\n  };\n\n  dynamics.spring = function(options) {\n    var A1, A2, decal, frequency, friction, s;\n    if (options == null) {\n      options = {};\n    }\n    applyDefaults(options, arguments.callee.defaults);\n    frequency = Math.max(1, options.frequency / 20);\n    friction = Math.pow(20, options.friction / 100);\n    s = options.anticipationSize / 1000;\n    decal = Math.max(0, s);\n    A1 = function(t) {\n      var M, a, b, x0, x1;\n      M = 0.8;\n      x0 = s / (1 - s);\n      x1 = 0;\n      b = (x0 - (M * x1)) / (x0 - x1);\n      a = (M - b) / x0;\n      return (a * t * options.anticipationStrength / 100) + b;\n    };\n    A2 = function(t) {\n      return Math.pow(friction / 10, -t) * (1 - t);\n    };\n    return function(t) {\n      var A, At, a, angle, b, frictionT, y0, yS;\n      frictionT = (t / (1 - s)) - (s / (1 - s));\n      if (t < s) {\n        yS = (s / (1 - s)) - (s / (1 - s));\n        y0 = (0 / (1 - s)) - (s / (1 - s));\n        b = Math.acos(1 / A1(yS));\n        a = (Math.acos(1 / A1(y0)) - b) / (frequency * (-s));\n        A = A1;\n      } else {\n        A = A2;\n        b = 0;\n        a = 1;\n      }\n      At = A(frictionT);\n      angle = frequency * (t - s) * a + b;\n      return 1 - (At * Math.cos(angle));\n    };\n  };\n\n  dynamics.bounce = function(options) {\n    var A, fn, frequency, friction;\n    if (options == null) {\n      options = {};\n    }\n    applyDefaults(options, arguments.callee.defaults);\n    frequency = Math.max(1, options.frequency / 20);\n    friction = Math.pow(20, options.friction / 100);\n    A = function(t) {\n      return Math.pow(friction / 10, -t) * (1 - t);\n    };\n    fn = function(t) {\n      var At, a, angle, b;\n      b = -3.14 / 2;\n      a = 1;\n      At = A(t);\n      angle = frequency * t * a + b;\n      return At * Math.cos(angle);\n    };\n    fn.initialForce = true;\n    return fn;\n  };\n\n  dynamics.gravity = function(options) {\n    var L, bounciness, curves, elasticity, fn, getPointInCurve, gravity;\n    if (options == null) {\n      options = {};\n    }\n    applyDefaults(options, arguments.callee.defaults);\n    bounciness = Math.min(options.bounciness / 1250, 0.8);\n    elasticity = options.elasticity / 1000;\n    gravity = 100;\n    curves = [];\n    L = (function() {\n      var b, curve;\n      b = Math.sqrt(2 / gravity);\n      curve = {\n        a: -b,\n        b: b,\n        H: 1\n      };\n      if (options.initialForce) {\n        curve.a = 0;\n        curve.b = curve.b * 2;\n      }\n      while (curve.H > 0.001) {\n        L = curve.b - curve.a;\n        curve = {\n          a: curve.b,\n          b: curve.b + L * bounciness,\n          H: curve.H * bounciness * bounciness\n        };\n      }\n      return curve.b;\n    })();\n    getPointInCurve = function(a, b, H, t) {\n      var c, t2;\n      L = b - a;\n      t2 = (2 / L) * t - 1 - (a * 2 / L);\n      c = t2 * t2 * H - H + 1;\n      if (options.initialForce) {\n        c = 1 - c;\n      }\n      return c;\n    };\n    (function() {\n      var L2, b, curve, _results;\n      b = Math.sqrt(2 / (gravity * L * L));\n      curve = {\n        a: -b,\n        b: b,\n        H: 1\n      };\n      if (options.initialForce) {\n        curve.a = 0;\n        curve.b = curve.b * 2;\n      }\n      curves.push(curve);\n      L2 = L;\n      _results = [];\n      while (curve.b < 1 && curve.H > 0.001) {\n        L2 = curve.b - curve.a;\n        curve = {\n          a: curve.b,\n          b: curve.b + L2 * bounciness,\n          H: curve.H * elasticity\n        };\n        _results.push(curves.push(curve));\n      }\n      return _results;\n    })();\n    fn = function(t) {\n      var curve, i, v;\n      i = 0;\n      curve = curves[i];\n      while (!(t >= curve.a && t <= curve.b)) {\n        i += 1;\n        curve = curves[i];\n        if (!curve) {\n          break;\n        }\n      }\n      if (!curve) {\n        v = options.initialForce ? 0 : 1;\n      } else {\n        v = getPointInCurve(curve.a, curve.b, curve.H, t);\n      }\n      return v;\n    };\n    fn.initialForce = options.initialForce;\n    return fn;\n  };\n\n  dynamics.forceWithGravity = function(options) {\n    if (options == null) {\n      options = {};\n    }\n    applyDefaults(options, arguments.callee.defaults);\n    options.initialForce = true;\n    return dynamics.gravity(options);\n  };\n\n  dynamics.bezier = (function() {\n    var Bezier, Bezier_, yForX;\n    Bezier_ = function(t, p0, p1, p2, p3) {\n      return (Math.pow(1 - t, 3) * p0) + (3 * Math.pow(1 - t, 2) * t * p1) + (3 * (1 - t) * Math.pow(t, 2) * p2) + Math.pow(t, 3) * p3;\n    };\n    Bezier = function(t, p0, p1, p2, p3) {\n      return {\n        x: Bezier_(t, p0.x, p1.x, p2.x, p3.x),\n        y: Bezier_(t, p0.y, p1.y, p2.y, p3.y)\n      };\n    };\n    yForX = function(xTarget, Bs, returnsToSelf) {\n      var B, aB, i, lower, percent, upper, x, xTolerance, _i, _len;\n      B = null;\n      for (_i = 0, _len = Bs.length; _i < _len; _i++) {\n        aB = Bs[_i];\n        if (xTarget >= aB(0).x && xTarget <= aB(1).x) {\n          B = aB;\n        }\n        if (B !== null) {\n          break;\n        }\n      }\n      if (!B) {\n        if (returnsToSelf) {\n          return 0;\n        } else {\n          return 1;\n        }\n      }\n      xTolerance = 0.0001;\n      lower = 0;\n      upper = 1;\n      percent = (upper + lower) / 2;\n      x = B(percent).x;\n      i = 0;\n      while (Math.abs(xTarget - x) > xTolerance && i < 100) {\n        if (xTarget > x) {\n          lower = percent;\n        } else {\n          upper = percent;\n        }\n        percent = (upper + lower) / 2;\n        x = B(percent).x;\n        i += 1;\n      }\n      return B(percent).y;\n    };\n    return function(options) {\n      var Bs, points, returnsToSelf;\n      if (options == null) {\n        options = {};\n      }\n      points = options.points;\n      returnsToSelf = false;\n      Bs = (function() {\n        var i, k, _fn;\n        Bs = [];\n        _fn = function(pointA, pointB) {\n          var B2;\n          B2 = function(t) {\n            return Bezier(t, pointA, pointA.cp[pointA.cp.length - 1], pointB.cp[0], pointB);\n          };\n          return Bs.push(B2);\n        };\n        for (i in points) {\n          k = parseInt(i);\n          if (k >= points.length - 1) {\n            break;\n          }\n          _fn(points[k], points[k + 1]);\n        }\n        return Bs;\n      })();\n      return function(t) {\n        if (t === 0) {\n          return 0;\n        } else if (t === 1) {\n          return 1;\n        } else {\n          return yForX(t, Bs, returnsToSelf);\n        }\n      };\n    };\n  })();\n\n  dynamics.easeInOut = function(options) {\n    var friction, _ref;\n    if (options == null) {\n      options = {};\n    }\n    friction = (_ref = options.friction) != null ? _ref : arguments.callee.defaults.friction;\n    return dynamics.bezier({\n      points: [\n        {\n          x: 0,\n          y: 0,\n          cp: [\n            {\n              x: 0.92 - (friction / 1000),\n              y: 0\n            }\n          ]\n        }, {\n          x: 1,\n          y: 1,\n          cp: [\n            {\n              x: 0.08 + (friction / 1000),\n              y: 1\n            }\n          ]\n        }\n      ]\n    });\n  };\n\n  dynamics.easeIn = function(options) {\n    var friction, _ref;\n    if (options == null) {\n      options = {};\n    }\n    friction = (_ref = options.friction) != null ? _ref : arguments.callee.defaults.friction;\n    return dynamics.bezier({\n      points: [\n        {\n          x: 0,\n          y: 0,\n          cp: [\n            {\n              x: 0.92 - (friction / 1000),\n              y: 0\n            }\n          ]\n        }, {\n          x: 1,\n          y: 1,\n          cp: [\n            {\n              x: 1,\n              y: 1\n            }\n          ]\n        }\n      ]\n    });\n  };\n\n  dynamics.easeOut = function(options) {\n    var friction, _ref;\n    if (options == null) {\n      options = {};\n    }\n    friction = (_ref = options.friction) != null ? _ref : arguments.callee.defaults.friction;\n    return dynamics.bezier({\n      points: [\n        {\n          x: 0,\n          y: 0,\n          cp: [\n            {\n              x: 0,\n              y: 0\n            }\n          ]\n        }, {\n          x: 1,\n          y: 1,\n          cp: [\n            {\n              x: 0.08 + (friction / 1000),\n              y: 1\n            }\n          ]\n        }\n      ]\n    });\n  };\n\n  dynamics.spring.defaults = {\n    frequency: 300,\n    friction: 200,\n    anticipationSize: 0,\n    anticipationStrength: 0\n  };\n\n  dynamics.bounce.defaults = {\n    frequency: 300,\n    friction: 200\n  };\n\n  dynamics.forceWithGravity.defaults = dynamics.gravity.defaults = {\n    bounciness: 400,\n    elasticity: 200\n  };\n\n  dynamics.easeInOut.defaults = dynamics.easeIn.defaults = dynamics.easeOut.defaults = {\n    friction: 500\n  };\n\n  dynamics.css = makeArrayFn(function(el, properties) {\n    return applyProperties(el, properties, true);\n  });\n\n  dynamics.animate = makeArrayFn(function(el, properties, options) {\n    var id;\n    if (options == null) {\n      options = {};\n    }\n    options = clone(options);\n    applyDefaults(options, {\n      type: dynamics.easeInOut,\n      duration: 1000,\n      delay: 0,\n      animated: true\n    });\n    options.duration = Math.max(0, options.duration * slowRatio);\n    options.delay = Math.max(0, options.delay);\n    if (options.delay === 0) {\n      return startAnimation(el, properties, options);\n    } else {\n      id = dynamics.setTimeout(function() {\n        return startAnimation(el, properties, options, id);\n      }, options.delay);\n      return animationsTimeouts.push({\n        id: id,\n        el: el\n      });\n    }\n  });\n\n  dynamics.stop = makeArrayFn(function(el, options) {\n    if (options == null) {\n      options = {};\n    }\n    if (options.timeout == null) {\n      options.timeout = true;\n    }\n    if (options.timeout) {\n      animationsTimeouts = animationsTimeouts.filter(function(timeout) {\n        if (timeout.el === el && ((options.filter == null) || options.filter(timeout))) {\n          dynamics.clearTimeout(timeout.id);\n          return false;\n        }\n        return true;\n      });\n    }\n    return animations = animations.filter(function(animation) {\n      return animation.el !== el;\n    });\n  });\n\n  dynamics.setTimeout = function(fn, delay) {\n    return addTimeout(fn, delay * slowRatio);\n  };\n\n  dynamics.clearTimeout = function(id) {\n    return cancelTimeout(id);\n  };\n\n  dynamics.toggleSlow = function() {\n    slow = !slow;\n    if (slow) {\n      slowRatio = 3;\n    } else {\n      slowRatio = 1;\n    }\n    return typeof console !== \"undefined\" && console !== null ? typeof console.log === \"function\" ? console.log(\"dynamics.js: slow animations \" + (slow ? \"enabled\" : \"disabled\")) : void 0 : void 0;\n  };\n\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    module.exports = dynamics;\n  } else if (typeof define === \"function\") {\n    define('dynamics', function() {\n      return dynamics;\n    });\n  } else {\n    window.dynamics = dynamics;\n  }\n\n}).call(this);\n\n},{}],2:[function(require,module,exports){\n\"use strict\";\n\nvar Dynamics = require('./dynamics.js');\n\nvar smallBeat = function(el, count) {\n  var duration = [300, 150];\n  var scales = [1.05, 1.0];\n  var friction = [200, 100];\n  var anticipationSize = [100, 67];\n  var frequency = [1000, 1];\n\n  Dynamics.animate(el, {\n    scale: scales[count]\n  }, {\n    type: Dynamics.spring,\n    duration: 757,\n    frequency: frequency[count],\n    friction: 1000,\n    anticipationSize: anticipationSize[count],\n    anticipationStrength: 1000\n  })\n\n  if (count < 3) {\n    count++;\n    setTimeout(function() { smallBeat(el, count) }, duration[count] * 1.10);\n  }\n\n}\n\nvar el = document.getElementById(\"logo\");\nsetInterval (function() { smallBeat(el, 0) }, 3500);\n\n},{\"./dynamics.js\":1}]},{},[2])\n\n","\"use strict\";\n\nvar Dynamics = require('./dynamics.js');\n\nvar smallBeat = function(el, count) {\n  var duration = [300, 150];\n  var scales = [1.05, 1.0];\n  var friction = [200, 100];\n  var anticipationSize = [100, 67];\n  var frequency = [1000, 1];\n\n  Dynamics.animate(el, {\n    scale: scales[count]\n  }, {\n    type: Dynamics.spring,\n    duration: 757,\n    frequency: frequency[count],\n    friction: 1000,\n    anticipationSize: anticipationSize[count],\n    anticipationStrength: 1000\n  })\n\n  if (count < 3) {\n    count++;\n    setTimeout(function() { smallBeat(el, count) }, duration[count] * 1.10);\n  }\n\n}\n\nvar el = document.getElementById(\"logo\");\nsetInterval (function() { smallBeat(el, 0) }, 3500);\n"],"sourceRoot":"/source/"}